<!DOCTYPE html>
	
<html>
	<head>
        <meta charset="UTF-8"/>
		<title>Электронный паспорт оборудования</title>
		<link href="css/iconsfont.css" rel="stylesheet" type="text/css"/>
		<link href="style_ert.css" rel="stylesheet" type="text/css"/>
	</head>
	<body>
	<div class="dws-menu">
<ul>
<li id="li1"><a href="#"><i class="fas fa-address-card"></i>Полезная документация</a>
<ul>
<li><a href="#">Госты</a></li>
<li><a href="#">Снипы</a></li>
<li><a href="#">Приказы</a></li>
<li><a href="#">Инструкции</a></li>
<li><a href="#">Лицензии и гарантии</a></li>
</ul>
</li>
<li><a href="#"><i class="fas fa-hdd"></i>Вычислительная техника</a>
<ul>
<li><a href="#">Компьютер</a></li>
<li><a href="#">Монитор</a></li>
<li><a href="#">Принтер</a>
<ul>
<li><a href="#">Samsung</a></li>
<li><a href="#">Philips</a></li>
<li><a href="#">Xerox</a></li>
</ul>
</li>
<li><a href="#">Сканер</a></li>
<li><a href="#">Сервер</a></li>
</ul>
</li>
<li><a href="#"><i class="fab fa-facebook-square"></i>Новости</a>
<ul>
<li><a href="#">Новости</a></li>
</ul>
</li>
<li><a href="#"><i class="fas fa-user"></i>Авторизация</a>
<ul>
<li><a href="#">Авторизация </a></li>
</ul>
</li>
<li id="li2"><a href="#"><i class="fas fa-phone"></i>Контакты</a>
<ul>
<li><a href="#">Контакты</a></li>
</ul>
</li>
</ul>
</div>


<h3> 6 Ограничение жадности в регулярках</h3><!-- 6 Ограничение жадности в регулярках -->
<div id="parent6"></p><!-- тег области  -->
	<p id="parent62">1</p><!-- тег параграфа  -->
</div>

<h3> 7 Математические операции с числами</h3><!-- 7 Математические операции с числами -->
<div id="parent7"></p><!-- тег области  -->
</div>

<h3> 8 Математические операции с переменными</h3><!-- 8 Математические операции с переменными -->
<div id="parent8"></p><!-- тег области  -->
</div>

<h3> 9 Приоритет математических операций</h3><!-- 9 Приоритет математических операций -->
<div id="parent9"></p><!-- тег области  -->
</div>

<h3> 10 Дроби</h3><!-- 9 Дроби -->
<div id="parent10"></p><!-- тег области  -->
</div>

<h3> 11 Отрицательные числа</h3><!-- 11 Отрицательные числа -->
<div id="parent11"></p><!-- тег области  -->
</div>

<h3> 12 Остаток от деления</h3><!-- 12 Остаток от деления -->
<div id="parent12"></p><!-- тег области  -->
</div>

<h3> 13 Возведение в степень</h3><!-- 13 Возведение в степень -->
<div id="parent13"></p><!-- тег области  -->
</div>

<h3> 14 Строки</h3><!-- 14 Строки -->
<div id="parent14"></p><!-- тег области  -->
</div>

<h3> 15 Сложение строк</h3><!-- 15 Сложение строк -->
<div id="parent15"></p><!-- тег области  -->
</div>

<h3> 16 Длина строки</h3><!-- 15 Длина строки -->
<div id="parent16"></p><!-- тег области  -->
</div>

<script  type="text/javascript">



//___________________________________________________
// 6 ПЕРЕМЕННЫЕ
//Основным понятием любого языка программирования является переменная. 
//Переменная представляет собой контейнер, в котором мы можем хранить какие-либо данные, 
//например, строки или числа.
//Для того, чтобы использовать переменную, ее сначала необходимо объявить: 
//написать перед ее именем ключевое слово let.
//После объявления переменной в нее можно записать 
//(говорят присвоить ей) какое-либо значение, например, какое-либо число или строку.
let parent_6 = document.querySelector('#parent6')//в переменную передаем значение тега дива
let num1 = 3;	// присваиваем переменной а значение 3
//А теперь давайте выведем содержимое этой переменной на экран с помощью функции alert:
//alert( "Переменная num =" + num ); 	//выводим 'Переменная num =3' с помощью функции alert
let p6 = document.createElement('p')// создаем переменную с тегом p - параграф
p6.innerHTML = "Переменная num =" + num1// cозданному тегу передаем значение 'Переменная num =3'
parent_6.append(p6)//позиционируем новый тег 
let a6;//объявляем переменную a6
a6 = 5;// значение переменной равно 5
console.log(a6); //выводим в консоль
a6 = 6/3;// значение переменной равно 2
console.log(a6);//выводим в консоль
a6 = 9.6;// значение переменной равно 9.6
console.log(a6);//выводим в консоль
a6 = 33+33;// значение переменной равно 66
console.log(a6);//выводим в консоль
a6 = 33-33;// значение переменной равно 0
console.log(a6);//выводим в консоль
a6 = 33*33;// значение переменной равно 1089
console.log(a6);//выводим в консоль
a6 = 33/33;// значение переменной равно 1
console.log(a6);//выводим в консоль
a6 = 33**2; // значение переменной равно 1089
console.log(a6);//выводим в консоль
let parent_62 = document.querySelector('#parent62')//в переменную передаем значение тега параграфа
parent_62.innerHTML = '33**2='+a6// тегу параграфа передаем значение а6

//___________________________________________________
// 7 МАТЕМАТИЧЕСКИЕ ОПЕРАЦИИ С ЧИСЛАМИ
let parent_7 = document.querySelector('#parent7')//в переменную передаем значение тега дива
let a7 = 1 + 2;//объявляем переменную равную значению выполненной операции 
let b7 = 3 - 2;//объявляем переменную равную значению выполненной операции 
let c7 = 3 * 2;//объявляем переменную равную значению выполненной операции 
let d7 = 4 / 2;//объявляем переменную равную значению выполненной операции 
let p71 = document.createElement('p')// создаем переменную с тегом p - параграф
p71.innerHTML = '1 + 2='+a7// cозданному тегу передаем значение 'Переменная num =3'
let p72 = document.createElement('p')// создаем переменную с тегом p - параграф
p72.innerHTML = '3 - 2='+b7// cозданному тегу передаем значение 'Переменная num =3'
let p73 = document.createElement('p')// создаем переменную с тегом p - параграф
p73.innerHTML = '3 * 2='+c7// cозданному тегу передаем значение 'Переменная num =3'
let p74 = document.createElement('p')// создаем переменную с тегом p - параграф
p74.innerHTML = '4 / 2='+d7// cозданному тегу передаем значение 'Переменная num =3'
parent_7.append(p71)//позиционируем новый тег 
parent_7.append(p72)//позиционируем новый тег 
parent_7.append(p73)//позиционируем новый тег 
parent_7.append(p74)//позиционируем новый тег 

//___________________________________________________
// 8 МАТЕМАТИЧЕСКИЕ ОПЕРАЦИИ С ПЕРЕМЕННЫМИ
//Математические операции можно производить не только над числами, но и над переменными.
let parent_8 = document.querySelector('#parent8')//в переменную передаем значение тега дива
let a8 = 1;//объявляем переменную
let b8 = 2;//объявляем переменную
let c8 = (a8 + b8); // выведет 3
let p8 = document.createElement('p')// создаем переменную с тегом p - параграф
p8.innerHTML = '(a8 + b8)='+c8// cозданному тегу передаем значение 'Переменная num =3'
parent_8.append(p8)//позиционируем новый тег 

//___________________________________________________
// 9 ПРИОРИТЕТ МАТЕМАТИЧЕСКИХ ОПЕРАЦИЙ
//Математические операции JavaScript имеют такой же приоритет, как в обычной математике. 
//То есть в начале выполняется умножение и деление, а потом уже сложение и вычитание.
let parent_9 = document.querySelector('#parent9')//в переменную передаем значение тега дива
let a9 = 1;//объявляем переменную
let b9 = 2;//объявляем переменную
let c9 = 3;//объявляем переменную
let d9 = a9 + b9 * c9;//объявляем переменную которой передаем выражение
let p9 = document.createElement('p')// создаем переменную с тегом p - параграф
p9.innerHTML = 'a9 + b9 * c9='+d9// cозданному тегу передаем значение 'Переменная num =3'
parent_9.append(p9)//позиционируем новый тег 

//___________________________________________________
// 10 ДРОБИ
//В JavaScript можно работать с десятичными дробями.
// При этом целая и дробная части отделяются друг от друга точкой.
let parent_10 = document.querySelector('#parent10')//в переменную передаем значение тега дива
let a10 = 0.5 + 0.5;//объявляем переменную которой передаем выражение
let p10 = document.createElement('p')// создаем переменную с тегом p - параграф
p10.innerHTML = '0.5 + 0.5='+a10// cозданному тегу передаем значение '0.5 + 0.5=1'
parent_10.append(p10)//позиционируем новый тег 

//___________________________________________________
// 11 ОТРИЦАТЕЛЬНЫЕ ЧИСЛА
//Числа могут быть отрицательными. Для этого перед числом необходимо поставить знак минус
let parent_11 = document.querySelector('#parent11')//в переменную передаем значение тега дива
let a11 = 1;//объявляем переменную
let b11 = -a11; // записали в b11 содержимое a11 с обратным знаком выведет -1
let p11 = document.createElement('p')// создаем переменную с тегом p - параграф
p11.innerHTML = b11// cозданному тегу передаем значение -1
parent_11.append(p11)//позиционируем новый тег 

//___________________________________________________
// 12 ОСТАТОК ОТ ДЕЛЕНИЯ
//Существует специальный оператор %, с помощью которого можно найти остаток от деления одного числа на другое
let parent_12 = document.querySelector('#parent12')//в переменную передаем значение тега дива
let a12 = 10;//объявляем переменную
let b12 = 3;//объявляем переменную
let c12 = 2;//объявляем переменную
let p121 = document.createElement('p')// создаем переменную с тегом p - параграф
let p122 = document.createElement('p')// создаем переменную с тегом p - параграф
let d121 = a12 % b12//показывает остаток от деления 10/3=3.333 (1 в остатке - проверка на нечетность) 
let d122 = a12 % c12 //показывает остаток от деления 10/2=5 - четное
p121.innerHTML = d121// cозданному тегу передаем значение -1
parent_12.append(p121)//позиционируем новый тег 
p122.innerHTML = d122// cозданному тегу передаем значение -1
parent_12.append(p122)//позиционируем новый тег 

//___________________________________________________
// 13 ВОЗВЕДЕНИЕ В СТЕПЕНЬ
//Для возведения числа в степень также существует специальный оператор **
//Операция возведения в степень имеет приоритет перед умножением и делением.
let parent_13 = document.querySelector('#parent13')//в переменную передаем значение тега дива
let a13 = 10;//объявляем переменную
let b13 = 3;//объявляем переменную
let c13 = 2;//объявляем переменную
let d13 =a13*b13**c13;//объявляем переменную
let p13 = document.createElement('p')// создаем переменную с тегом p - параграф
p13.innerHTML = d13// cозданному тегу передаем значение 90
parent_13.append(p13)//позиционируем новый тег, выведет 90

//___________________________________________________
// 14 СТРОКИ
// данные могут иметь различный тип. Один из типов - числа, теперь перейдем к строкам.
//Между одинарными и двойными кавычками в JavaScript нет никакой разницы. 
//Их использование зависит от ваших предпочтений. 
let parent_14 = document.querySelector('#parent14')//в переменную передаем значение тега дива
let w14 = "rer";
let p14 = document.createElement('p')// создаем переменную с тегом p - параграф
p14.innerHTML = w14// cозданному тегу передаем значение "rer"
parent_14.append(p14)//позиционируем новый тег, 

//___________________________________________________
// 15 CЛОЖЕНИЕ СТРОК
//Для сложения строк, так же, как и для сложения чисел, используется оператор
let y15 = "wer" + "!!" + "sdf";//объявляем переменную строку
console.log(y15); // выводит "wer!!sdf"
let parent_15 = document.querySelector('#parent15')//в переменную передаем значение тега дива
let str151 = 'abc';//объявляем переменную строку
let str152 = 'def';//объявляем переменную строку
let str15 = (str151 + ' ' + str152); // выведет 'abc def'
let p15 = document.createElement('p')// создаем переменную с тегом p - параграф
p15.innerHTML = str15// cозданному тегу передаем значение 'abc def'
parent_15.append(p15)//позиционируем новый тег, выведет 'abc def'

//___________________________________________________
// 16 ДЛИННА СТРОКИ
//Количество символов в строке содержится в свойстве length
let parent_16 = document.querySelector('#parent16')//в переменную передаем значение тега дива
let str16;
str16 = "werwqrea";
console.log(str16.length); //выводит 8 -длинну строки ФУНКЦИЯ(ОБЪЕКТ.СВОЙСТВО)
let p16 = document.createElement('p')// создаем переменную с тегом p - параграф
p16.innerHTML = str16+ ' = '+ str16.length// cозданному тегу передаем значение 'werwqrea = 8'
parent_16.append(p16)//позиционируем новый тег, выведет 'awerwqrea = 8'





//___________________________________________________
// 18 СПЕЦИАЛЬНЫЕ ЗНАЧЕНИЯ

//let rrew = undefined;
//alert(rrew); 	//выведет undefined - образует неопределенность, 
				//бывает у переменной если ее объявили, но не записали значения в нее

//let tt = null;
//alert(tt); 	// выводит null - обозначает "ничего", мы можем присвоить переменной,
				//такое значение если хотим отметить, что там ничего не лежит
				
//let t;
//t = true;
//alert(true); // выводит true
//t = false;
//alert(false); // выводит false //значения true/false обозначают истину или ложь. 
				//Они используются для таких вещей, которые предпологают два варианта ответа - да или нет

//alert('abc' * 'abd'); // выведет NaN -  (Not-A-Number) обозначает не число. 
						//Такое значение получается тогда, когда вы пытаетесь делать математические операции не с числами, 
						//или умножить строки.

//alert( 1 / 0); // выведет Infinity 
//alert(-1 / 0); // выведет -Infinity - (бесконечность) на 0 делить можно

//___________________________________________________
	// 6 РАБОТА С КОНСОЛЬЮ и ФУНКЦИИ ВЫВОДА alert, prompt и confirm

//var oi = 6; 	//директива (оператор) var - объявляет переменную глобально или локально во всей функции
				//let директива (оператор) объявляет локальную переменную с областью видимости,
				//ограниченной текущим блоком кода
	//let name = prompt('Ваше имя?');
//alert (name)	//выведет сообщение 'Ваше имя?' и поле для ввода текстового сообщения 

//let name = confirm ('Ваше имя?'); //выведет сообщение 'Ваше имя?' и две кнопки выбора -OK и ОТМЕНА

//alert (name);
//console.log(oi); //выводит сведения в консоль просмотра кода

//___________________________________________________
	// 7 КОНСТАНТЫ

//const pi = 3.14; 	
//alert (pi); 	//директива (оператор) const - в них можно записывать данные только один раз, 
				//затем значение изменить нельзя
				
//___________________________________________________
	// 9 Автоматическое преобразование типов данных
	
//alert('2' * '3'); // выведет 6 - строку, но не объединит в 23

//let z = '5' * 1 + '2' * 1; // выведет 7, но объединит
//alert(z);

//let a = 2 + 3 + '1';
//alert(a); // выведет '51'

//___________________________________________________
	// 10 Принудительное преобразование типов данных

//let aa = '3'; 
//let bb = '3';
//alert(Number(aa) + Number(bb)); 	// выведет 6, принудительная сменав значений в числвой формат 
									//с помощью специальной функции Namber

//let ab = Number('2'); // в переменную запишется число 2
//let ba = Number('3'); // в переменную запишется число 3
//alert(ab + ba); // выведет 5

//let a = +'2'; // в переменную запишется число 2
//let b = +'3'; // в переменную запишется число 3
//alert(a + b); // выведет 5

//let numm = parseFloat('12.5px');
//alert(numm); 	// выведет 12.5 - специальная функция parseFloat -Выделение числа, работает только со строками, 
				//разбирает строку и вычлиняет числовую состовляющую, может быть и parseInt


//let strr = String(123); 
//alert(strr); // выведет строку '123' с помощью специальной функции String (строка) 

//let num1 = 1;
//let num2 = 2;
//alert(String(num1) + String(num2)); // выведет '12', переводит числа в строку 

//let nuum = 12345;
//let strrr = String(nuum); // преобразуем наше число к строке
//alert(strrr.length);     	// найдем длину строки

//___________________________________________________
	// 11 Принудительное логического типа
	
//alert(String(true));  // выведет 'true' 
//alert(String(false)); // выведет 'false' // переводит значение true\false в строки


//alert(Number(true));  // выведет 1 
//alert(Number(false)); // выведет 0 // переводит значение true\false в числа

//___________________________________________________
	// 12 Преобразование к логическому типу
	
//console.log(Boolean(0));          // выводит false - преобразование к логическому типу осуществляется 
									//с помощью функции Boolean 
//console.log(Boolean(-0));         // выводит false
//console.log(Boolean(+0));         // выводит false
//console.log(Boolean(null));       // выводит false
//console.log(Boolean(false));      // выводит false
//console.log(Boolean(NaN));        // выводит false
//console.log(Boolean(undefined));  // выводит false
//console.log(Boolean(''));         // выводит false
//console.log(Boolean(-1));          // true
//console.log(Boolean(Infinity));    // true
//console.log(Boolean(-Infinity));   // true
//console.log(Boolean('0'));         // true
//console.log(Boolean('false'));     // true
//console.log(Boolean('NaN'));       // true
//console.log(Boolean('null'));      // true
//console.log(Boolean('undefined')); // true

//___________________________________________________
	// 13 Получение символов строки
	
//let strq = 'abcde'; // строка
//alert(strq[0]); // выведет 'a'
//alert(strq[1]); // выведет 'b'
//alert(strq[2]); // выведет 'c'
//let nummm = 3; // номер символа в переменной
//alert(str[nummm]); 	// выведет 'd' // для получения символов строки исползуют написание 
						//- имя переменной и квадратные скобки

//let a = "asdfi"; //строка
//alert(a[0]);
//alert(a[1]); // выведет 's'
//alert(a[2]); // выведет 'd'
//alert(a[3]); // выведет 'f' 
//let num = 4;
//alert(a[num]); // выведет 'i' - в квадратные ковычки можно записывать переменные

//let e = 'asdfg';
//let r = e.length - 1;
//alert(e[r]); // выведет 'g' последний символ строки

//let test = String(12345); // строка
//alert(test[0]); // выведет '1' - выведет первый символ строки
//alert(test[0] + test[1]); // выведет '12' - суммирует как строки
//alert(Number(test[0]) + Number(test[1])); // выведет 3

//___________________________________________________
	// 14 Сокращенные операции
	
//let num = 1;   // объявляем переменную num и записываем в нее значение 1
//num = num + 2; // записываем в num ее саму плюс 2
//alert(num);    // выведет 3 //над переменной можно провести какую либо операцию, а потом вписать в туже переменную

//let num = 1;
//num += 3; 
//alert(num); // выведет 4 - эквивалентно num = num + 3;

//___________________________________________________
	// 15 Операции инкремент, декремент 

//let num = 0;
//num++;        // прибавляем к переменной num число 1
//alert(num);   // выведет 1

//let num = 0;
//alert(++num); // выведет 1 - переменная увеличилась сразу

//let num = 0;
//num--;        // отнимаем от переменной num число 1
//alert(num);   // выведет -1

//___________________________________________________
	// 16 функция prompt

//let name = prompt('Ваше имя?');
//alert('Ваше имя: ' + name);
//let num1 = prompt('Введите первое число');
//let num2 = prompt('Введите второе число');
//alert(num1 + num2); // сложит числа как строки

//___________________________________________________
	// 17 Массивы
	
//let arr = ['пн', 'вт', 'ср', 'чт', 'пт', 'сб', 'вс'];
//alert (arr); 	// выводит 'пн,вт,ср,чт,пт,сб,вс' //создаем массив arr, 
				//массив - переменная, которая хранит множество значений

//let arre = [1, 2, 'a', 'b', null, true, false]; 
//alert (arre); //выводит '1,2,a,b,null,true,false, может хранить в себе все виды данных
//alert (arre[0]); //выведет 1
//alert (arre[1]); //выведет 2
//alert (arre[2]); //выведет а
//alert (arre[3]); //выведет b

//let arre = [1, 2, 'a', 'b', null, true, false]; 
//console.log (arre[4]); //выведет null 

//let arrt  = [3,7,6];
//alert (arrt.length);// выводится также как и со строкой, с помощью специального свойства length

//let arrtf = [1, 2, 3];
//console.log(arrtf[arrtf.length - 1]) // выведет 3 - находим последний элемент массива

//let arri = ['a', 'b', 'c'];
//arri[0] = '!'; // изменяем первый элемент массива 
//console.log(arri); // выведет ['!', 'b', 'c']

//let arer = ['a', 'b', 'c'];
//arer[0] = arer[0] + '!';
//arer[1] = arer[1] + '!';
//arer[2] = arer[2] + '!';
//console.log(arer); // выведет ['a!', 'b!', 'c!']

//let arr = [1, 2, 3, 4];
//arr[0]++;
//++arr[1];
//arr[2]--;
//--arr[3];
//console.log(arr); // выведет [2, 3, 2, 3]

//let arre = []; // создаем пустой массив и можем добавить в него элементы
//arre[0] = 'a'; // в ключ 0 добавим элемент 'a'
//arre[1] = 'b'; // в ключ 1 добавим элемент 'b'
//arre[2] = 'c'; // в ключ 2 добавим элемент 'c'
//console.log (arre); // выведет ['a', 'b', 'c']

//___________________________________________________
	// 18 Объекты

//let obj = {1: 'пн', 2: 'вт', 3: 'ср', 4: 'чт', 5: 'пт', 6: 'сб', 7: 'вс'};
//console.log(obj[1]); 	// выведет 'пн' применяется объект (ассоциативный массив или хеш) который объявляется с помощью {} 
						//и  ключей объявленных в нем. Объект или ассоц. массив является неупорядоченным списком

//let objt = {key1: 'a', key2: 'b', key3: 'c'};
//console.log(objt); // выведет {key1: 'a', key2: 'b', key3: 'c'} выводит сам объект с ключами, 
//alert выведет значение -object
//console.log(objt['key1']); //выведет 'a'

//let obj = {key1: 'a', key2: 'b', key3: 'c'};
//console.log(obj.key1); // альтернативный способ - обращение через свойство объекта.

//let obj = {};
//obj['key1'] = 'a';
//obj['key2'] = 'b';
//obj['key3'] = 'c';
//console.log(obj); // выведет {key1: 'a', key2: 'b', key3: 'c'}

//___________________________________________________
	// 19 Ключи из переменных
	
//let arr = ['a', 'b', 'c'];
//let key = 0; // запишем ключ в переменную
//console.log(arr[key]); // выведет 'a'

//___________________________________________________
	// 20 Типизация масивов и объектов

//console.log( typeof {a: 1, b: 2, c: 3} ); 	// выведет 'object' - спеиальная функия typeof проверяет тип данных 
												//string, number, boolean, null, undefined, symbol.
//let r = true;
//console.log( typeof (r)); // выводит boolean

//console.log( typeof (5)); // выводит number

//console.log( Array.isArray([2, 3, 2, 3]) ); 		// выведет true - спеиальная функия Array.isArray проверяет массив 
													//(объект) на достоверность true/false
//console.log( Array.isArray({a: 1, b: 2, c: 3}) ); // выведет false

//___________________________________________________
	// 21	 Передача объектов по ссылке
	
//let a = [1, 2, 3];
//let b = a;
//b[0] = '!'; // меняем массив из переменной b
//console.log(a[0]); // выведет '!' - переменная a тоже поменялась

//let a = [1, 2, 3];
//let b = a; // на объект ссылается и a, и b
//a = 'primitive'; // запишем в a какой-то примитив, запись примитива в одну из переменных не повлияет на вторую переменную 
//- она по-прежнему будет указывать на тот же объект
//console.log(b); // выведет [1, 2, 3]

//let a = [1, 2, 3];
//let b = a;
//a = [3, 4, 5]; // запишем в a массив
//console.log(b); // выведет [1, 2, 3]
//console.log(a); // выведет [3, 4, 5]

//___________________________________________________
	// 22	 Оператор in

//let objw = {a: 1, b: 2, c: 3};
//console.log('b' in objw); // выведет true с помощью оператора (спец функции) in можно проверить
// наличие в нашем объекте какого-нибудь свойства
//console.log('x' in objw); // выведет false

//___________________________________________________
	// 23	 Оператор delete

//let objs = {a: 1, b: 2, c: 3}; 
//delete objs.c;
//console.log (objs); // выведет {a: 1, b: 2} // оператор (функция)delete удаляет элементы массива

//___________________________________________________
	// 24	 Констаны с массивами и объектами
	
//const objww = {a: 1, b: 2, c: 3}; 
//objww.a = '+'; // работает!
//console.log (objww); //выводит {a: '+', b: 2, c: 3} // Констаны в JS не меняют значения, 
//но изменять свойства элементов объекта и массива - можно.

//___________________________________________________
	// 25	 Подход программирования через константы
	
//const aaa = 1;
//const bbb = 2;
//const ccc = aaa + bbb;
//console.log(ccc); //вместо let мы везде используем const

//___________________________________________________
	// 26	 Конструкция if-else
	
//let a = 1;
//if (a > 0) 
//{ 
//alert ("Хороший день ");
//}
//else (a <= 0)
//{
//alert ("Плохой день"); //  if (если) -else (в противеом случае еще) - конструкция (условие) которое позволяет выполнять некоторый код 
//в зависимости от выполнения какого-либо условия.
//}

//let test = 'abc';
//if (test == 'abc') //Проверка на равенство
//{
//alert('Верно');
//}
//else 
//{
///alert( 'неверно');
//}

//let test = 1; // пусть значение переменной равно 1
//if (test != 0) 
//{
//alert('верно'); // сработает этот alert, так как переменная НЕ равна 0
//} 
//else 
//{
//alert('неверно'); //Проверка на неравенство
//}

//___________________________________________________
	// 27	Типы данных и конструкция if-else
	
	
//if ('3' == 3) 
//{
//alert('верно'); // сработает этот alert - значения равны - равенство по значению
//} else {
//alert('неверно'); //выведет - верно / 
//}

//if ('3' === 3) {
//alert('верно');
//} else {
//alert('неверно'); // выведет - неверно //сработает этот alert - равенство по значению и типу 
//}

//___________________________________________________
	// 28	Сложные условия в if-else  операторы && (логическое И) и || (логическое ИЛИ).

//let r = 4;
//if (r <10 && r > 1)
//{
//alert ( "Значение соответствует" + r); // выведет -"Значение соответствует 4"
//}
//else;
//{
//alert ( "Значение = " + r + ", оно не соответствут заданному");
//}


//let num1 = 2;
//let num2 = 3;

//if (num1 == 2 && num2 == 3) {
//	alert('верно'); //выведет - 'верно'
//} else {
	//alert('неверно');
//}

//let num11 = 10;
//let num12 = -5;
//if (num11 > 0 || num12 > 0) {
//	alert('верно'); // выведет 'верно'
//} else {
	//alert('неверно');
//}


//let p = 0;
//let o = 4;
//if (p > 0 || o > 4)
//{
//alert('Верно');
//}
//else 
//{
//alert('Не верно'); //выведет 'неверно'
//}

//___________________________________________________
	// 29	Инвертирование высказываний в if-else
	
//let numbf = 4;
//if ( !(numbf > 0 && numbf < 5) ) { //знак ! представляет логическую НЕ, ставится перед функцией
//alert('верно');
//} else {
//alert('неверно');
//}

//___________________________________________________
	// 30	Конструкция if-else и булевы значения
	
//let test = true;
//if (test === true) 
//{
//alert('верно'); 
//}//выведет true//булева переменная, которая может принимать значения true или false
//else {
//alert('неверно');
//}

//let test = 0;
//if (test == true) {// конвертирует 0 в логический тип boolean
//alert('верно');
//} else {
//alert('неверно'); // сработает этот alert, тк 0 == true - это НЕверно. 
//Значения, которые при приведению к логическому типу дают 
//false: 0, -0, +0, null, false, NaN, undefined, '' (пустая строка). -Урок 12
//}

//___________________________________________________
	// 31	Сокращенный синтаксис if-else
	
//let d = 10;
//if (d == 10) 
//{
//alert('yes'); // Необязательность конструкции else, на экран выведется алерт 'yes' только в том случае, 
//если значение переменной равно 1. В противном случае просто ничего не случится
//}

//if (test == 0)
//alert('верно');
//else
//alert('неверно!'); //Необязательность фигурных скобок, 
//если в фигурных скобках if или else будет только одно выражение, можно эти фигурные скобки не писать.


//___________________________________________________
	// 32	Комбинации конструкций if-else
	
//let a = 1;
//if (a ==1)
//{
//alert ("значение 1"); //Конструкция условия из 3 if
//}
//if (a ==2)
//{
//alert ("значение 2");
//}
//if (a==3)
//{
//alert ("Значение 3");
//}

//let a = 3;
//if (a ==1)
//{
//alert ("значение 1"); 
//}
//else if (a ==2)
//{
//alert ("значение 2");
//}
//else if (a==3)
//{
//alert ("Значение 3"); //специальная конструкция else if
//}
	
//let num = 1;
//if (num == 1)
//{
//alert('value1');
//} 
//else if (num == 2) 
//{
//alert('value2');
//}
//else if (num == 3)
//{
//alert('value3');
//} 
//else 
//{
//alert('неверное значение переменной num'); //реимуществом использования 
//else if вместо нескольких ифов является возможность отловить ситуацию,
//когда значение переменной num не подходит ни под одно из условий
//}

//let num = 3;
//if (num >= 0) 
//{
	//if (num <= 5) 
	//{
		//alert('меньше или равно 5');
	//} 
	//else 
	//{
		//alert('больше 5');
	//}
//} 
//else 
//{
	//alert('меньше нуля'); // Вложенные if, Конструкции if-else можно вкладывать друг в 
	//друга произвольным образом
//}

//___________________________________________________
	// 33	Область видимости let и var в if-else
	
	//if (true)
	//{
	//let result = '!';
//}
//console.log(result);  // Ошибка, переменные, объявленные внутри фигурных скобок, 
//видны только внутри этих скобок, и не видны снаружи

//let result; // переменная объявлена снаружи
//if (true) {
	//result = '!';
//}
//console.log(result); // выведет '!'

//let test = true;
//let result; // объявим переменную снаружи условия

//if (test) {
	//result = 1;
//} else {
	//result = 2;
//}
//console.log(result); // выведет 1
	
	//if (true) {
	//let result = '!';
//}
//console.log(result); // выдаст ошибку
//А вот если объявить переменную через var - то переменная будет видна снаружи условия:

//if (true) {
//var result = '!';
//}
//console.log(result); // выведет '!'

//___________________________________________________
	// 36	Конструкция switch-case
	
	//switch (переменная) {
	//case 'значение1':
		/*
			здесь код, который выполнится в случае,
			если переменная имеет значение1
		*/
	//break;
	//case 'значение2':
		/*
			здесь код, который выполнится в случае,
			если переменная имеет значение2
		*/
	//break;
	//case 'значение3':
		/*
			здесь код, который выполнится в случае,
			если переменная имеет значение3
		*/
	//break;
	//default:
		/*
			здесь код, который выполнится в случае,
			если не совпала ни с одним значением
		*/
	//break;
//}

//let a = 13;
//switch (a) {
	//case 1:
		//alert('значение а = 1');
	//break;
	//case 2:
		//alert('значение а = 2');
	//break;
	//case 3:
		//alert('значение а = 3');
	//break;
	//default:
		//alert('искомых значений нет');
	//break;
//} 


//let num = 1;
//let result;
//switch (num) {
	//case 1:
	//case 2:
		//result = 'a';
	//break;
	//case 3:
		//result = 'b';
	//break;
//}
//alert(result);

//Конструкция switch-case. Нет разницы, какой вариант решения выбрать: через switch-case или через if. 
//Решение через switch-case в данном случае считается более выразительным. При этом 
//в блоке case нужно писать какое-то конкретное значение - там нельзя использовать логические операции (==, больше, меньше и тп). 
//switch-case используется для выбора одного значения из некоторого ряда значений. 
//Если вам нужно нечто более сложное - необходимо использовать ифы.

//___________________________________________________
	// 37	Тернарный оператор
	//let age = 17;
	//let adult;
	//if (age >= 18)
	//{
	//adult = true;
	//}
	//else
	//{
	//adult = false;
	//}
	//console.log(adult);
		//||
		//\/
	//let age = 22;
	//let adult = age >=18 ? true: false;
	//console.log (adult);
		//||
		//\/
	//let age = 15;
	//console.log (age >=18 ? true: false); //Можно не записывать результат в переменную, а сразу вывести в консоль//Для  задач, 
	//когда  происходит только запись одной переменной, 
	//существует короткое решение - через тернарный оператор. Его синтаксис таков:
	//let переменная = условие ? значение1 : значение2;
	
	//___________________________________________________
	// 38	Логические операции

//let a = 1;
//let b = 1;
//console.log(a == b); //конструкция if не является обязательной для сравнения - 
//сами операторы вида ==, ===, !=, <, > и т.д. возвращают своим результатом либо true, либо false

//console.log(1 == 1); // выведет true
//console.log(1 == 2); // выведет false
//Можно не выводить результат сразу в консоль, а присвоить его какой-нибудь переменной


	//console.log('abc' == 'abc'); // Сравнение строквыведет true
	//console.log('aab' > 'aaa'); // условие на большее\меньшее, выведет true
	//console.log('2019-12-30' >= '2020-11-29'); //  Сравнение дат, выведет false
	
	//___________________________________________________
	// 39	Функция confirm
	
	//let w = confirm('Текст вопроса');//функция confirm выведет диалоговое окно с вопросом  и двумя кнопками для ответа: с кнопкой 'ОК' и с кнопкой 'Отмена'.
	//Если вы нажмете 'Ок' то в переменную w запишется true, а если нажмете 'Отмена' - то false,
	//if (w) {
	//alert('вы ответили да');
	//} else {
	//alert('вы ответили нет');
	//}
	
		//___________________________________________________
	// 40	Цикл while
	
	//let i = 1; //задаем какую-нибудь переменную
	//while (i <= 10) // цикл будет выполняться до тех пор, пока верно (истинно) выражение, 
	//переданное ему параметром
	//{
	//console.log (i); // выводим содержимое i в консоль
	//i++; // увеличиваем i на единицу при каждом проходе цикла
	//}
	
	
	//let i = 2;
	//while (i <= 10) {
	//console.log(i);
	//i += 2; // увеличиваем i на 2 при каждом проходе цикла
	//}
	
	//let i = 10; // начальное значение 10
	//while (i >= 1) { // пока i больше 1
	//console.log(i);
	//i--; // уменьшаем i на единицу
	//}
	
		//___________________________________________________
	// 41	Ошибки начинающих при работе с циклом while (бесконечные цыклы)
	
	//let i = 1;
	//while (i <= 10)
	// {
	//console.log(i);
	//}

	//___________________________________________________
	// 42	Цикл for

/*
	В начале цикла i будет равно нулю,
	цикл будет выполнятся пока i <= 9,
	после каждого прохода к i прибавляется 2:
*/
//for (let i = 1; i <= 9; i+= 2) {
	//console.log(i); // выведет 1, 3... 9
//}// Цикл for является альтернативой while. синтаксис :for ( начальные команды; условие окончания; команды после прохода ) 
//{
	//тело цикла
//}
//Условие окончания цикла (i <= 9)- это условие, при котором цикл будет крутится, пока оно истинное

//___________________________________________________
	// 43	Накопление результата в цикле 
	
	//let result = 0;
	//for (let i = 1; i <= 100; i++) {
	//result = i + result;
	//console.log(result); // искомая сумма
	//}//Это решение заключается в том, что циклом перебираются числа 
	//и их сумма последовательно записывается в какую-то переменную
	
	//___________________________________________________
	// 44	Цикл for для массивов
	
	//let arr = [1, 2, 3, 4, 5];
	//for (let i = 0; i < arr.length; i++) { //цикл for от 0 до 4 и внутри этого цикла будем выводить элементы массива, 
	//обращаясь к ним как arr[i]:
	//console.log(arr[i]); // выведет 1, 2, 3, 4, 5
	//}
	
	
	//let result = 0;
	//let arr = [1, 2, 3, 4, 5];
	//for (let i = 0; i < arr.length; i++) {
	//result += arr[i];
	//console.log(result);
	//}
	
		//___________________________________________________
	// 45	 Перебор массива циклом for-of
	
	//let arr = [1, 2, 3, 4, 5];
//for (let elem of arr) {
	//console.log(elem); //В ES6 появился новый цикл for-of, предназначенный конкретно для перебора массивов. Он имеет следующий синтаксис:
//}
	/*
		В переменнуюДляЭлемента по очереди
		будут попадать элементы перебираемого массива.
	*/
//}

//___________________________________________________
	// 46	 Перебор объекта циклом for-in
	
//let obj = {a: 1, b: 2, c: 3}; //цикл for-in, предназначен для перебора объектов
//for (let key in obj) {
//console.log(key); // выведет 'a', 'b', 'c'
//}

//___________________________________________________
	// 47	 Сокращенный синтаксис циклов
	
	//for (let i = 0; i <= 9; i++)
//console.log(i); // выведет числа от 0 до 9 //Опустим фигурные скобки - 
//и результат от этого не изменится

//___________________________________________________
	// 48	 Общий синтаксис цикла
	
	//for (let i = 0, j = 0; i <= 9; i++, j += 2) {
	//console.log(i, j); //начальные команды и команды после прохода цикла могут состоять не из одной, 
	//а из нескольких, разделяемых запятыми
	
	//___________________________________________________
	// 49	 Инструкция break
	
	//let arr = [1, 2, 3, 4, 5];
	//for (let elem of arr) {
	//if (elem == 3) {
	//console.log('есть');
	//break; // выйдем из цикла //специальная инструкции break, позволяет досрочно завершить работу цикла
	//}
	//}
	//___________________________________________________
	// 50	 Инструкция continue
	
	//let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
	//for (let elem of arr) 
		//{
		//let result;
		//if (elem % 2 == 0) 
			//{
			//result = elem * elem;
			//} 
		//else if (elem % 3 == 0) 
			//{
			//result = elem * elem * elem;
			//} 
		//else 
			//{
			//continue; // перейдем на новую итерацию цикла
			//}
		//console.log(result); // выполнится, если делится на 2 или 3
	//}
	
	//___________________________________________________
	// 51	Область видимости let и var в циклах
	
	//for (let i = 1; i <= 9; i++)
	//{
	//let num = 3;
	//console.log(num); // выведет 3, переменная применилась
	//}
	
	//let num; //  Можно объявить переменную снаружи цикла - 
	//тогда она будет доступна как внутри цикла, так и снаружи
	//for (let i = 1; i <= 9; i++) {
	//num = 3; // установим ей значение
	//}
	//console.log(num); // выведет 3
	
	//for (let i = 1; i <= 9; i++) 
	//{
	//let num = 3; // При таком написании переменная -num применяется
	//только внутри цикла
	//}
	//console.log(num); // выдаст ошибку так как переменную не видно внутри цыкла
	
	//___________________________________________________
	// 52	Работа с флагами
	
//Задача вывести на экран значение 4 если она есть массиве, если нет вывести нет
//let m = [1, 2, 4, 7, 4];
//for (let g of m)
//{
//if (g == 4)
//{
//console.log (g + '=искомое значение');
//break;
//}
//else 
//{
//console.log('нет'); // выведет на элементах 1, 2, 4, 5
//}
//}
//Для решения задач подобного типа (такие задачи встречаются достаточно часто) и используют так называемые флаги.
//Флаг - это такая переменная, которая может принимать два значения: true или false.


//let arr = [1, 2, 3, 4, 5];
//let flag = false;
//for (let elem of arr) 
//{
//if (elem == 3) 
//{
//flag = true;
//break;
//}
//}
//if (flag === true) //видятся за циклом 
//{
//console.log('есть');
//} else //переменная flag равна или true, или false
//{
//console.log('нет');
//}

	//___________________________________________________
	// 53	Нахождение простых чисел
	
	//let num = 40;
	//let flag = true;
	//for (let i = 2; i < num; i++) 
	//{
	//if (num % i == 0)// если остатка от деления нет = 0 то false 
	//{
		//flag = false; // если хотя бы один раз поделилось
		//break; 
	//}
	//}
//console.log(flag)// выведем значение счетчика

//___________________________________________________
	// 54	Циклы while без заданного количества итераций
	
//Бывают задачи, в которых количество итераций цикла не известно заранее.
//let num = 500; // переменная
//while (num > 10) // условие
//{
	//num = num / 2;
	//console.log(num); // получим результат
//}

//for (var num = 500, i = 0; num > 10; num = num / 2, i++);
//console.log(num, i);
//переменная num объявлена через var - это нужно для того, 
//чтобы переменная была доступна после цикла.

//___________________________________________________
	// 55	Формирование строк через циклы 
	
//let str = ''; // начальное значение - пустые кавычки
//for (let i = 0; i < 10; i++) //цикл 
//{
//str = str + 'x'; //	можно записать str += 'x';
//}
//console.log(str); // выведет 'xxxxxxxxxx'

//___________________________________________________
	// 56	Цикл for и типы данных
	
	//let n = 1;
	//for (let i = 10; i <= 1000; i++)
	//{
	//let numm = String (i);// преобразование переменной в строку
	//if (Number(numm[0]) + Number(numm[1]) == 5)// чтобы работать с элементами числа нужно енго 
	// преобразовать в строку с помощью функции String, для сложения переделываем строкив числа,
	// находим сложения
	//{
	//console.log ( n + ' значение = ' +  numm); // выводим результат в консоль - "1 значение = 14", "2 значение = 23"...
	//n++; // счетчик
	//}
	//}
	

//let result = ''; // начальное значение - пустая строка
//for (let i = 1; i <= 30; i++) {
	//result = result + String(i); // преобразуем i к строке 
	//с помощью String() , можно писать с сокращением - result += i; 
//}
//console.log(result);

//___________________________________________________
	// 57	Вложенные циклы
	
	//for (let i = 1; i <= 9; i++) 
	//{
	//for (let j = 1; j <= 3; j++) // выполняет итерации по условию, затем прекращается и переходит
	//на внешний цикл
	//{
	//document.write(i); // выводит на экран
	//}
//}
//let a = 5;
		//document.write( '|| результат ='  + a); // выводит на экран
		
		
		//for (let i = 10; i < 40 ; i+=10)// цикл отвечающий за добавление десяток
		//{
		//for (let j = 1; j <= 4; j++)// цикл отвечающий за перебор 1-4
		//{
		//document.write( ' ' + i + ' '); // вывод
		//i++; // добавляем единицу
		//}
		//i = i-3; // приводим счетчик в начальное значение
		//}
		
		//___________________________________________________
	// 58	Вложенные циклы и область видимости
	
	//for (let i = 0; i <= 9; i++) 
	//{
	//for (let j = 0; j <= 9; j++) 
	//{
		//let num = 3;
	//}
	//console.log(num); // выдаст ошибку, вывод переменной невозможен так как он вне цикла
//}
//console.log(num); // выдаст ошибку

	//___________________________________________________
	// 59	Заполнение массивов через цикл
	
		//let n = [];
		//n[0] = 1;
		//n[1] = 2;
		//n[2] = 3;
		//n[3] = 4;
		//n[4] = 5;
		//n[5] = 6;
		//n[6] = 7;
		//n[7] = 8;
		//n[8] = 9;
		//n[9] = 10;
		//console.log(n);
		//||
		//\/	
	//let arr = [];// упрощенный способ
	//for (let i = 0; i <= 4; i++) { // массив заполнился  циклом for
	//arr[i] = i + 1;
	//}

	//console.log(arr);
		
	//	let g = [];
	//	g[0] = 'x';
	//	g[1] = 'x';
	//	g[2] = 'x';
	//  g[3] = 'x';
	//	g[4] = 'x';
		//console.log(g);
		
//let arr = [];
//arr[0] = 1;
//arr[4] = 5;
//console.log(arr); // выведет структуру массива в виде [1, undefined × 3, 5]
//alert(arr);  // выведет структуру массива в виде 1,'','','',5
//console.log(arr.length); // выведет 5, хотя мы вроде как добавили лишь 2 элемента
//ропущенные элементы все равно будут присутствовать в массиве, 
//просто их значение будет undefined

//let arr = [];
//for (let i = 2, j = 0; i <= 100; i += 2, j++) 
//{
//arr[j] = i; //Заполнение значениями не по порядку
//}
//console.log(arr); // массив получится с пропусками

//___________________________________________________
	// 60	Изменение массива в цикле
	
//let arr = [1, 2, 3, 4, 5];
//arr[0] = arr[0] * 2;
//arr[1] = arr[1] * 2;
//arr[2] = arr[2] * 2;
//arr[3] = arr[3] * 2;
//arr[4] = arr[4] * 2;
//console.log(arr); // выведет [2, 4, 6, 8, 10]
//||
//\/
//let arr = [1, 2, 3, 4, 5];
//for (let i = 0; i < arr.length; i++) {
//arr[i] = arr[i] * 2;
//}
//console.log(arr); // выведет [2, 4, 6, 8, 10]

//___________________________________________________
	// 61	Заполнение массива методом push
	//let a =[];
	//a[0] = 1; 
	//a[1] = 2; 
	//a[2] = 3; 
	//a[3] = 4; 
	//a[4] = 5; 
	//console.log(a); // выведет [1, 2, 3, 4, 5] - такое написание массива можно упростить
	//используя специальный метод push
	//||
	//\/
	//let b = [];
	//b.push(1);
	//b.push(2);
	//b.push(3);
	//b.push(4);
	//b.push(5);
	//console.log(b); // выведет [1, 2, 3, 4, 5] 
	
	//let numm = [];
	//for (let i = 1; i <=10; i++)// цикл для массива
	//{
	//numm.push(i); //запись массива методом push
	//}
	//console.log(numm);// вывод в консоль
	
	//k = 0;
	//let m = [];
	//let i = [10, 32, 453, 54, 75, 4546, 57, 68, 69];
	//for (let a = 0; a <= i.length - 1; a++) //цикл для массива
	//{
	//if (i[a] % 2 == 0)// условие на четность - остаток по модулю
	//{
	//m[k] = i[a];	//запись результата в отдельный массив
	//document.write( ' ' + i[a] + ' ');// вывод в документ
	//k++;
	//}
	//}
	//console.log (m);// вывод массива в консоль
	
	//___________________________________________________
	// 62	Заполнение объектов через цикл
	
//let obj = []; //объявляем массив obj (нельзя мешать объект с массивом, расчет не будет проводиться, или выводить поэлементно) 
//obj[0] = 'a';
//obj[1] = 'b';
//obj[2] = 'c';
//obj[3] = 'd';
//obj[4] = 'e';
//console.log (obj); //объявляем массив mas
//let mas = [];
//mas[0] = 1;
//mas[1] = 2;
//mas[2] = 3;
//mas[3] = 4;
//mas[4] = 5;
//console.log (mas);
//let rez ={};//объявляем пустой объект
//for (let i =0; i <= obj.length - 1; i++) // цикл, присваиваем значения поэлементно в тело обекта
//{
//rez[obj[i]] = mas[i];
//}
//console.log (rez);// выводим заполненный объект, значения из двух массивов


//let obj = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5}; //объявляем объект obj
//let result = {}; // пустой объект result
//for (let key in obj) //цикл for-in  для объектов (есть for -of для массивов) -перебирает все ключи, 
//может перебирать и элементы 
//{
//if (obj[key] % 2 == 0)//проверяем делится ли остаток на 2 (на четность)
//{
//result[key] = obj[key];
//}
//}
//console.log(result); // выведет {'b': 2, 'd': 4};


//let obj = {a: 1, b: 2, c: 3, d: 4, e: 5}; //меняем местами ключи и значения в объекте
//let result = {};
//for (let key in obj) {
//result[obj[key]] = key;
//}
//console.log(result); // выведет {1: 'a', 2: 'b', 3: 'c', 4: 'd', 5: 'e'}

	//___________________________________________________
	// 64	Подсчет количества элементов в массиве и проверка на заполненность
	
//let arr = ['a', 'b', 'c', 'a', 'a', 'b']; // объявляем массив
//for (let key of arr) // цикл по ключу массива
//{
//if (key = 5) //условие
//{
//console.log(arr[key]); // выводит значение из 5 элементе массива
//}
//}

//let arr = ['a', 'b', 'c', 'a', 'a', 'b'];// объявляем массив
//let counter = 0;// объявляем счетчик
//for (let elem of arr)  // цикл поэлементу массива
//{
//if (elem == 'a')//условие
//{
//counter++; // перебор, итерации счетчика
//}
//}
//console.log(counter);// выводит колличество элементов со значением 'a'

//___________________________________________________
	// 65	Получение соседей элементов в массиве
	
//let arr = [1, 5, 12, 77, 103]; // назначаем массив (определяем диапазоны прироста)
//for (let i = 1; i < arr.length; i++) //цикл перебора элементов в массиве начиная со 2 так как у 0 элемента нет предыдущего
//{
//console.log(arr[i] - arr[i - 1]);// находим предыдущий и отнимаем от текущего, находим диапазон
//}

//___________________________________________________
	// 66	Получение чисел Фибоначчи

//let one = 0; //начальное
//let two = 1;//последующее
//for (let i = 1; i <= 10; i++) //функциия из последовательности
//{
//let rez = one + two; //начальное+последующее
//console.log(rez);//вывод результата в консоль
//one = two;// присваиваем зачения последующего начальному
//two = rez;// присваиваем зачения результата последующему
//}

//___________________________________________________
	// 67	Вывод пирамидок (заполнение экрана)

//let str = '';//создаем пустую строку
//for (let i = 0; i < 5; i++) // цикл из 5 элементов с итерациями по порядку
//{
//str += 'x';//добавление в строку х
//document.write(str + '<br>');// вывод на экран и переход на новую строку (теги можно также объявлять через '')
//}

//___________________________________________________
	// 68	Заполнение массивов с накоплением строки
	
//let arr = []; // создаем пустой массив
//let str = '';//создаем пустую строку
//for (let i = 0; i < 5; i++)//цикл с 5 итерациями по порядку
//{
//str += 'x';//при каждом проходе записываем Х в str
//arr.push(str);// записываем значение str в массив
//}
//console.log(arr); // выведет ['x', 'xx', 'xxx', 'xxxx', 'xxxxx']

//___________________________________________________
	// 69	Отработка циклов (Практика)
	
// 1)Выведите с помощью цикла столбец чисел от 1 до 100.
//let a = [];
//for (i = 0; i <100; i++)
//{
//a[i] = i+1;
//document.write (a[i] + '<br/>');
//} 

//2) Выведите с помощью цикла столбец чисел от 100 до 1.

//let a = [];
//for (i = 101; i > 1; i--)
//{
//a[i] = i-1;
//document.write (a[i] + '<br/>');
//} 

// 3) Выведите с помощью цикла строку четных чисел от 1 до 100.

//let arr = []
//let a = [];
//for (i = 0; i <100; i++)
//{
//a[i] = i+1;
//if ( a[i] % 2 == 0)
//{
//arr.push(a[i]);
//} 
//}
//document.write (arr);

// 4) Заполните массив 10-ю иксами с помощью цикла.
//let arr = []
//for (i = 0; i <10; i++)
//{
//arr += 'x';
//}
//console.log(arr);
//console.log (arr.length);

// 5) Заполните массив числами от 1 до 10 с помощью цикла.
//let a = [];
//for (i = 0; i <10; i++)
//{
//a[i] = i+1;
//}
//console.log(a);

//6) Дан массив с числами. С помощью цикла выведите только те элементы массива, которые больше 20 и меньше 50-ти.
//let arr =[];
//let m = [10, 13, 45, 12, 78, 66, 43, 67, 99, 21];
//for (i = 0; i <m.length -1; i++)
//{
//if (m[i] > 20 && m[i] < 50)
//{
//arr.push(m[i]);
//}
//}
//console.log(arr);

//7) Дан массив с числами. С помощью цикла проверьте, что в нем есть элемент со значением 66.
//let n = 0;
//let m = [10, 13, 45, 12, 5, 66, 43, 67, 99, 21];
//for (let elem of m) 
//{
//n++;
//if (elem == 66) 
//{
//console.log('есть =' + m[n -1]);
//break;
//}
//else 
//{
//console.log('не найдено');
//}
//}

//8) Дан массив с числами. С помощью цикла найдите сумму элементов этого массива.
//let n = 0;
//let m = [10, 13, 45, 12, 5, 66, 43, 67, 99, 21];
//for (i = 0; i <= m.length -1; i++)
//{
//n += m[i];
//}
//console.log (n);

//9) Дан массив с числами. С помощью цикла найдите сумму квадратов элементов этого массива.
//let n = 0;
//let m = [1, 2, 3, 4, 5];
//for (i = 0; i <= m.length -1; i++)
//{
//n += m[i]**2;
//console.log (n);
//}
//console.log ('результат сложения квадратов = ' + n );

//10) Дан массив с числами. Найдите среднее арифметическое его элементов (сумма элементов, делить на количество).
//let n = 0;
//let m = [1, 2, 3, 4, 5];
//for (i = 0; i <= m.length -1; i++)
//{
//n += m[i];
//}
//let r = n/m.length;
//console.log ('среднеарифметическое = ' + r );

//11) Напишите скрипт, который будет находить факториал числа. Факториал (обозначается !) 
//- это произведение (умножение) всех целых чисел, меньше данного, и его самого. Например, 4! = 1*2*3*4.

//let n = 4;
//let r = 1;
//for (i = n; i > 0; i--)
//{
//r = r * i;
//}
//console.log (r);

//___________________________________________________
	// 70	Многомерные массивы
//let a = [['a', 'd', 'c'], ['d', 'e', 'f',], ['g', 'h', 'i']];// пример многомерного (двумерного)массива а
//alert (a)
//console.log (a);

//let mass = //объявление массива
//[
//['a', 'd', 'c'], 
//['d', 'e', 'f'], 
//['g', 'h', 'i']
//];
//console.log (mass[0][0], mass[1][1], mass[2][2])  //вывод элементов в консоль

//let arr = // пример трехмерного массива
//[
	//[
		//['a', 'b'],
		//['c', 'd'],
	//],
	//[
		//['e', 'f'],
		//['g', 'h'],
	//],
	//[
		//['i', 'j'],
		//['k', 'l'],
	//],
//];
//console.log (arr);// вывод в консоль
//console.log (arr[1][1][1], arr[1][1][0]);

//let arr = // пример трехмерного массива
//[
	//[
		//['a', 'b'],
		//['c', 'd'],
	//],
//];
//console.log (arr[0][0][0] + arr[0][0][1] + arr[0][1][0] + arr[0][1][1]); // вывод сложения

//let a = ''; //объявление строки
//let mass = //объявление массива
//[
//['a', 'd', 'c'], 
//['d', 'e', 'f'], 
//['g', 'h', 'i']
//];
//for (let elem of mass)//цикл
//{ 
// a += elem + ','; //Условие
//}
//console.log (a);// вывод результата - a,d,c,d,e,f,g,h,i,

//___________________________________________________
	// 71	Перебор многомерных массивов

//let arr = [[1, 2, 3, 4, 5], [6, 7, 8], [9, 10]];
//for (let subArr of arr) 
//{
//for (let elem of subArr)
//{
//console.log(elem);
//}
//}

//let a = '';// объявление переменной
//let mass = //объявление массива
//[
//['a', 'd', 'c'], 
//['d', 'e', 'f'], 
//['g', 'h', 'i']
//];
//for (let elem of mass)//цикл по массиву
//{ 
//for (let el of elem) //цикл в подмассиве
//{
//a += el; //условие
//}
//}
//console.log (a);// выводит adcdefghi


//let arr = [[1, 2, 3, 4, 5], [6, 7, 8], [9, 10]] //объявляем двумерный массив
//for (let i = 0; i < arr.length; i++)//цикл элементов массива
//{
//for (let j = 0; j < arr[i].length; j++)//цикл субэлементов массива
//{
//console.log(arr[i][j]);// вывод в консоль
//}
//}

//___________________________________________________
	// 72	Заполнение многомерных массивов
	
//let arr = []; //создаем массив
//for (let i = 0; i < 3; i++) {
//arr[i] = []; // создаем подмассив
//for (let j = 0; j < 3; j++) {
//arr[i][j] = j + 1; // заполняем подмассив числами
//}
//}
//console.log(arr);


//let arr = [];//создаем массив
//for (let i = 0; i < 3; i++) 
//{
//arr[i] = []; // создаем подмассив
//for (let j = 0; j < 3; j++) 
//{
//arr[i].push(j + 1); // заполняем подмассив числами c помощью метода push
//}
//}
//console.log(arr);

//let mass = [];
//for (let k = 0; k < 3; k++)
//{
//mass[k]=[];
//for (let i = 0; i < 2; i++)
//{
//mass [k][i] = [];
//for (let m = 0; m < 5; m++)
//{
//mass [k][i][m] = m + 1;
//}
//}
//}
//console.log(mass);

//let arr = [];
//let k = 1; // счетчик
//for (let i = 0; i < 3; i++)
 //{
//arr[i] = [];
//for (let j = 0; j < 3; j++) 
//{
//arr[i][j] = k; // записываем счетчик
//k++; // увеличиваем счетчик
//}
//}
//console.log(arr);


//___________________________________________________
	// 73	Многомерные объекты
	
//let obj =// Пример многомерного объекта
//{
	//a: {
		//key1: 'a1',
		//key2: 'a2',
		//key3: 'a3',
	//},
	//b: {
		//key1: 'b1',
		//key2: 'b2',
		//key3: 'b3',
	//},
	//c: {
		//1: 'c1',
		//2: 'c2',
		//3: 'c3',
	//},
//}
//console.log(obj['a']['key1']); // выведет 'a1'
//console.log(obj['c'][1]); // выведет 'c1'

//_____________________________________
//  74 Перебор многомерных объектов


//let obj = { //Объявление многомерного объекта
	//a: {
		//1: 'a1',
		//2: 'a2',
		//3: 'a3',
	//},
	//b: {
		//1: 'b1',
		//2: 'b2',
		//3: 'b3',
	//},
	//c: {
		//1: 'c1',
		//2: 'c2',
		//3: 'c3',
	//},
//}
//for (let key in obj) {//цикл перебора объектов 
	//let subObj = obj[key];//вычленение объектов в субобъект
	//for (let subKey in subObj) {//цикл перебора элементов субобъекта
		//console.log(subObj[subKey]);//вывод на экран значения объектов
	//}
//}

//let object = //Объявление многомерного объекта
//{
	//1: {
		//1: 11,
		//2: 12,
		//3: 13,
	//},
	//2: {
		//1: 21,
		//2: 22,
		//3: 23,
	//},
	//3: {
		//1: 24,
		//2: 25,
		//3: 26,
	//},
//}
//for (let r in object)//цикл перебора объектов 
//{
//let subobect = object [r]; //вычленение объектов в субобъект
//for (let n in subobect)//цикл перебора элементов субобъекта
//{
//console.log ( subobect [n]);//вывод на экран 11 12 13 21 22 23 24 25 26
//}
//}

//_____________________________________
//  75 Ключи из переменных в многомерных структурах
//let obj = 
//{
//'ru': ['пн', 'вт', 'cр', 'чт', 'пт', 'сб', 'вс'],
//'en': ['mn', 'ts', 'wd', 'th', 'fr', 'st', 'sn'],
//}
//console.log (obj['ru'][1]); // выведет - 'вт'

//let obj = 
//{
//'ru': ['пн', 'вт', 'ср', 'чт', 'пт', 'сб', 'вс'],
//'en': ['mn', 'ts', 'wd', 'th', 'fr', 'st', 'sn'],
//};
//let lang = 'ru';
//let day = 3;
//console.log(obj[lang][day]);// выведет - 'чт'

//let lang = 'ru'; // может быть или 'ru' или 'en'
//let month = 5;   // число от 0 до 11
//let months = {
	//'ru': [
		//'январь',
		//'февраль',
		//'март',
		//'апрель',
		//'май',
		//'июнь',
		//'июль',
		//'август',
		//'сентябрь',
		//'октябрь',
		//'ноябрь',
		//'декабрь',
	//],
	//'en': [
		//'january',
		//'february',
		//'march',
		//'april',
		//'may',
		//'june',
		//'july',
		//'august',
		//'september',
		//'october',
		//'november',
		//'december',
	//],
//};
//console.log(months[lang][month]); // выведет июнь

//let affairs = {
	//'2018': {
		//11: {
			//29: ['дело111', 'дело112', 'дело113'],
			//30: ['дело121', 'дело122', 'дело123'],
		//},
		//12: {
			//30: ['дело211', 'дело212', 'дело213'],
			//31: ['дело221', 'дело222', 'дело223'],
		//},
	//},
	//'2019': {
		//12: {
			//29: ['дело311', 'дело312', 'дело313'],
			//30: ['дело321', 'дело322', 'дело323'],
			//31: ['дело331', 'дело332', 'дело333'],
		//}
	//},
//}
//console.log(affairs ['2018'][11][29][0]); // выведет дело111

//_____________________________________
//  76 Многомерные массивы и объекты

//let days = 
//{
	//'ru': ['пн', 'вт', 'ср', 'чт', 'пт', 'сб', 'вс'],
	//'en': ['mn', 'ts', 'wd', 'th', 'fr', 'st', 'sn'],
//};
//console.log(days['ru'][0]); // выведет 'пн'
//console.log(days['en'][2]); // выведет 'wd'

//пример Массив объектов
//let users = [
	//{
		//name: 'name1',
		//age: 31,
	//},
	//{
		//name: 'name2',
		//age: 32,
	//},
	//{
		//name: 'name3',
		//age: 33,
	//},
//];
//console.log(users[1]['name']); // выведет 'name2'
//console.log(users[1]); // выведет {name: 'name2', age: 32}

//_____________________________________
//  77 Перебор многомерных комбинаций

//let users = [
	//{
		//name: 'name1',
		//age: 31,
	//},
	//{
		//name: 'name2',
		//age: 32,
	//},
	//{
		//name: 'name3',
		//age: 33,
	//},
//];
//for (let user of users) {
	//document.write(user.name + ' ' + user.age + '<br>');
//}

//let obj =
 //{
//'elem1': ['subelem11', 'subelem12', 'subelem13'],
//'elem2': ['subelem21', 'subelem22', 'subelem23'],
//'elem3': ['subelem31', 'subelem32', 'subelem33']
//}
//for (let elem in obj)
//{
//for (let name of obj[elem]) 
//{
//console.log(name);
//}
//}

//_____________________________________
//  78 математические методы в JavaScript
// Работа со степенью и корнем
//Метод Math.pow возводит число в заданную степень. Первым параметром передается число, 
//вторым - в какую степень его возвести.Синтаксис Math.pow(число, степень)
//console.log(Math.pow(3, 4));// выведеть 81

//Метод Math.sqrt возвращает квадратный корень числа. Синтаксис Math.sqrt(положительное число)
//console.log(Math.sqrt(4)); //результат 2

//Метод Math.ceil производит округление дробного числа до целого всегда в большую сторону.
//Синтаксис Math.ceil(число)
//console.log(Math.ceil(3.00001));//выводит 4

//Метод Math.floor производит округление числа до целых всегда в меньшую сторону.
//Синтаксис Math.floor(число)
//console.log(Math.floor(2.9999)); //выводит 2

//Метод Math.round выполняет округление до ближайшего целого числа 
//по правилам математического округления. Синтаксис Math.round(число)
//console.log(Math.round(6.4)); //выведет 6

//Метод toFixed производит округление числа до указанного знака в дробной части.
//Синтаксис число.toFixed([количество знаков в дробной части]);
//let num = 1.1111;
//console.log(num.toFixed(3));//вывод 1.111

//Метод toPrecision округляет число до заданного знака. В отличие от Math.round округление 
//можно проводить не только в дробной части. Параметром метода указывается сколько цифр должно 
//остаться в числе. Остальные цифры будут отброшены. Последнее оставшееся число будет округлено 
//по правилам математического округления.Если указанное количество знаков не достижимо обрезанием 
//десятичной части - переводит число в экспоненциальную форму. Экспоненциальная форма - это числа вида 1.2e+3.
//Чтобы преобразовать в нормальную форму нужно сделать так: 1.2e+3 = 1.2 * 10*3 = 1.2 * 1000 = 1200.
//Если параметр пуст, то будет возращено исходное число.
//let num = 678.19324;
//console.log(num.toPrecision(4));
//let m = num.toPrecision(4); //выведет  678.2
//document.write (m);//выведет  678.2

//Метод Math.max возвращает максимальное число из группы чисел, переданных в функцию.
//Если в функцию ничего не передано, то будет возращено -Infinity.
//По умолчанию функция не работает с массивами, однако с помощью хитрого приема можно найти максимальное значение массива: Math.max.apply(null, arr), 
//где arr - произвольный массив. Синтаксис Math.max(число, число, число...)
//console.log(Math.max(1, 5, 10, 34, 100)); //выведет 100

//let arr = [1, 5, 10, 34, 100,150];
//let max = Math.max.apply(null, arr);
//console.log(max); //выведет 150

//Метод Math.min возвращает минимальное число из группы чисел, переданных параметрами.
// Аналог функции Math.max
//console.log(Math.min(40, 20, 42, 100, 67)); //выведет 20

//Метод Math.random возвращает случайное дробное число от 0 до 1.
//Синтаксис Math.random()
//Получение случайного дробного числа между min и max:
//function getRandomArbitary(min, max) 
//{
//return Math.random() * (max - min) + min;
//}
//console.log(getRandomArbitary(10, 100));

//Получение случайного целого числа между min и max:
//function getRandomInt(min, max) 
//{
//return Math.floor(Math.random() * (max - min + 1)) + min;
//}
//console.log(getRandomInt(10, 100));

//Метод Math.abs возвращает модуль числа, то есть из отрицательного
// числа делает положительное.
//console.log(Math.abs(-3)); //выводит 3

//_____________________________________
// 79 Строковые методы JavaScript
// Метод toUpperCase производит преобразование строки в верхний регистр 
//(из маленьких букв делает большие). При этом возвращается новая строка, 
//а исходная строка не меняется.
// синтаксис строка.toUpperCase()
//let str = 'Язык JavaScript';
//console.log(str.toUpperCase()); //выведет ЯЗЫК JAVASCRIPT

//Метод split осуществляет разбиение строки в массив по указанному разделителю.
//Разделитель указывается первым необязательным параметром. Если он не задан - 
//вернется вся строка. Если он задан как пустые кавычки '' - то каждый символ 
//строки попадет в отдельный элемент массива. Вторым необязательным параметром можно 
//указать максимальное количество элементов в получившемся массиве
//Синтаксис строка.split([разделитель], [максимальное количество элементов]) 
//let str = 'html-css-javascript';
//let arr = str.split('-');
//console.log(arr); выведет ['html', 'css', 'javascript']

//метод toLowerCase производит преобразование строки в нижний регистр (из больших букв делает маленькие).
// При этом возвращается новая строка, а исходная строка не меняется. Синтаксис строка.toLowerCase()
//let str = 'Язык JAVASCRIPT';
//console.log(str.toLowerCase());//выведет 'язык javascript'

//let str = 'abcde';
//let arr = str.split('');
//console.log(arr); //выведет ['a', 'b', 'c', 'd', 'e']

//Метод substr возвращает подстроку из строки (исходная строка при этом не изменяется).
//первый параметр задает номер символа, с которого метод начинает отрезать (учтите, что нумерация с нуля), 
//а второй параметр - сколько символов отрезать. Синтаксис строка.substr(откуда отрезать, [сколько символов отрезать]) 
//let str = 'abcde';
//let sub = str.substr(0, 3);
//console.log(sub); //выведет  'abc'

//метод substring возвращает подстроку из строки (исходная строка при этом не изменяется).
//Первый параметр задает номер символа, с которого метод начинает отрезать (учтите, что нумерация с нуля), а второй параметр - 
//номер символа, на котором следует закончить вырезание (символ с этим номером не включается в вырезанную часть).
//синтаксис строка.substring(откуда начать отрезать, [докуда отрезать]) 
//let str = 'abcde';
//let sub = str.substring(1, 3);
//console.log(sub); возврвщает 'bc'

//Метод slice возвращает подстроку из строки (исходная строка при этом не изменяется).
//Первым параметром указывается номер символа строки, с которого начинается вырезание, а вторым параметром - номер символа, 
//на котором закончится вырезание (при этом символ с этим номером не включится в вырезанную часть).
//синтаксис строка.slice(откуда отрезать, [докуда отрезать]) 
//let str = 'abcde';
//let sub = str.slice(1, 3);
//console.log(sub); вернет bc

//Метод indexOf осуществляет поиск подстроки (указывается первым параметром) в строке.
//Метод вернет позицию первого совпадения, а если оно не найдено, то вернет -1.
//Вторым параметром (он необязателен) можно передать номер символа, откуда следует начинать поиск.
//синтаксис строка.indexOf(что ищем, [откуда начинать поиск]);
//let str = 'Я учу учу Javascript';
//console.log(str.indexOf('учу'));// вернет 2 (с этой позиции начинается первое слово 'учу' в строке)

//let str = 'Я учу учу Javascript';
//console.log(str.indexOf('учу', 5)); // вернет 6

//Метод lastIndexOf осуществляет поиск подстроки (указывается первым параметром) в строке.
//Поиск ведется с конца строки. Метод вернет позицию первого совпадения, а если оно не найдено, 
//то вернет -1. Синтаксис строка.lastIndexOf(что ищем, [откуда начинать поиск]);
//let str = 'Б..Б..Б';
//console.log(str.lastIndexOf('Б')); //верент 6 

//Метод startsWith() помогает определить, начинается ли строка с символов указанных в скобках, возвращая, 
//соответственно, true или false. Синтаксис str.startsWith(searchString[, position])
//let  str = 'Быть или не быть, вот в чём вопрос.';
//console.log(str.startsWith('Быть'));        // выведет true

//Метод endsWith() позволяет определить, заканчивается ли строка символами указанными в скобках, возвращая, 
//соответственно, true или false. Синтаксис str.endsWith(searchString[, length])
//let str = 'Быть или не быть, вот в чём вопрос.';
//console.log(str.endsWith('вопрос.'));   // выведет true

//Метод join объединяет элементы массива в строку с указанным разделителем 
//(он будет вставлен между элементами массива). Синтаксис массив.join([разделитель])
//let arr = [1, 2, 3];
//let str = arr.join('-'); //выведет '1-2-3'

//_____________________________________
// 80 Методы для массивов
// Метод push добавляет неограниченное количество элементов в конец массива. При этом исходный массив изменяется, 
//а результатом возвращается новая длина массива. Синтаксис массив.push(элемент, элемент, элемент...)
//let arr = ['a', 'b', 'c'];
//arr.push ('1', '2')
//console.log (arr); //выведет  ['a', 'b', 'c', '1', '2']

//let arr = [];
//for (let i = 1; i <= 9; i++) 
//{
//arr.push(i)
//}
//console.log(arr); //выведет [1, 2, 3, 4, 5, 6, 7, 8, 9]

//Метод unshift добавляет неограниченное количество новых элементов в начало массива. При этом исходный массив изменяется, 
//а результатом возвращается новая длина массива. Синтаксис массив.unshift(элемент, элемент, элемент...);
//let arr = ['a', 'b', 'c', 'd', 'e'];
//arr.unshift('1', '2');
//console.log(arr);// выведет ['1', '2', 'a', 'b', 'c', 'd', 'e']

//let arr = ['a', 'b', 'c', 'd', 'e'];
//let length = arr.unshift('1', '2');
//console.log(arr.length);выведет 7

//метод shift удаляет первый элемент из массива. При этом исходный массив изменяется, 
//а результатом метода возвращается удаленный элемент. Синтаксис массив.shift();
//let arr = ['a', 'b', 'c', 'd', 'e'];
//arr.shift();
//console.log(arr); //выведет ['b', 'c', 'd', 'e']

//метод pop удаляет последний элемент из массива. При этом исходный массив изменяется, 
//а результатом метода возвращается удаленный элемент. Синтаксис массив.pop()
//let arr = ['a', 'b', 'c', 'd', 'e'];
//arr.pop();
//console.log(arr); //вернет ['a', 'b', 'c', 'd']

//let arr = ['a', 'b', 'c', 'd', 'e'];
//let del = arr.pop();
//console.log(del);// вернет 'e'

//let arr = ['1', '2', '3', '4', '5', '6'];
//let result = [];
//while (arr.length > 0) { // массив уменьшается в цикле пока не достигнет нуля
//let first = arr.shift();
//let last  = arr.pop();
//let str = first + last; // тут будет строка '16', потом '25', потом '34' 
//result.push(str);
//}
// После цикла в result лежит массив ['16', '25', '34']. Сольем его в строку: 
//result = result.join('-');
//console.log(result); // результат '16-25-34'


//Метод slice вырезает и возвращает указанную часть массива.
//Первым параметром указывается номер элемента массива, с которого начинается вырезание,
//а вторым параметром - номер элемента, на котором закончится вырезание 
//(при этом элемент с этим номером не включится в вырезанную часть).
//Второй параметр также может принимать отрицательные значения. В этом случае отсчет элемента, 
//на котором закончится обрезание, начинается с конца массива. 
//Причем, последний элемент имеет номер -1, предпоследний -2 и так далее.
//Синтаксис массив.slice(откуда отрезать, [докуда отрезать]) 
//let arr = ['a', 'b', 'c', 'd', 'e'];
//let sub = arr.slice(0, 2);
//console.log(sub); //результат ['a', 'b']

//let arr = ['a', 'b', 'c', 'd', 'e'];
//let sub = arr.slice(1, -1);
//console.log(sub);//выведет ['b', 'c', 'd']

//Метод splice удаляет или добавляет элементы в массив. Можно только удалять элементы, 
//только добавлять или делать и то и другое одновременно. Метод очень универсальный и сложный для понимания.
//синтаксис массив.splice(откуда удаляем, сколько элементов удаляем, [вставить элемент], [вставить элемент]...);
//let arr = ['a', 'b', 'c', 'd', 'e'];
//arr.splice(1, 3);
//console.log(arr); //результат ['a', 'e']

//let arr = ['a', 'b', 'c', 'd', 'e'];
//let del = arr.splice(1, 3);
//console.log(del);//результат ['b', 'c', 'd']

//let arr = ['a', 'b', 'c', 'd', 'e'];
//arr.splice(2, 1, '1', '2', '3'); //результат ['a', 'b', '1', '2', '3', 'd', 'e']
//console.log(arr);


//Метод includes проверяет наличие элемента в массиве. Синтаксис массив.includes(элемент)
//let arr = [1, 2, 3, 4, 5];
//let result = arr.includes(3);
//console.log(result); //выводит true

//Метод indexOf() возвращает первый индекс, по которому данный элемент может быть найден в массиве или -1,
// если такого индекса нет.Синтаксис arr.indexOf(searchElement[, fromIndex = 0])
//let array = [2, 5, 9]; 
//console.log(array.indexOf(2)); //выведет 0
//console.log (array.indexOf(7));     //выведет -1
//console.log (array.indexOf(9, 2));  //выведет 2
//console.log (array.indexOf(2, -1)); //выведет -1
//console.log (array.indexOf(2, -3)); //выведет 0

//_____________________________________
// 81 Практика на использования изученных методов

//let str = 'london';
//let result = str.slice(0, 1).toUpperCase() + str.slice(1);
//console.log(result); // выведет 'London'

//let str = 'london';
//let result = str.slice(0, 1).toUpperCase() + str.slice(1, 5) + str.slice(-1).toUpperCase();
//console.log(result); // выведет 'LondoN'

//let str = 'london';
//let m = [];
//console.log (str );
//m [0] = str[0].toLowerCase();
//m [1] = str[1].toLowerCase();
//m [2] = str[2].toLowerCase();
//for (let i = 3; i <=  str.length - 2 ; i++)
//{
//m [i] = str[i].toUpperCase();
//}
//m [str.length - 1] = str[str.length - 1].toLowerCase();
//console.log (m);
//m = m.join('');
//console.log (m);
//document.write (m) ; //выведет lonDOn

//let str = 'london';
//let m = [];
//console.log (str );
//for (let i = 0; i <=  str.length - 2 ; i++)
//{
//m [i] = str[i].toLowerCase();
//}
//if (i = str.length - 1)
//{
//m [i] = str[i].toUpperCase();
//}
//console.log (m);
//m = m.join('');
//console.log (m);
//document.write (m) ; //выведет londoN

//let str = 'word1 word2 word3';
//let arr = str.split(' ');
//let result =[]; 
//for (i= 0; i <= arr.length - 1; i++){
//for (let j = 0; j <= arr[i].length-1; j++){
//if (j > 0 ) {
//result += arr [i][j];
//}
//else  {
//result += arr [i][j].toUpperCase();
//}
//}
//}
//let  itog = result.slice(0, 5) + ' ' + result.slice(5, 10) + ' ' + result.slice(10, 15);
//console.log (itog); //Word1 Word2 Word3

//let str = 'word1 word2 word3';
// Разобьем строку в массив слов:
//let words = str.split(' ');
//for (let i = 0; i < words.length; i++) {
	// Увеличим регистр каждого слова:
//words[i] = words[i].slice(0, 1).toUpperCase() + words[i].slice(1);
//}
//console.log(words)
// Сольем массив обратно в строку:
//let result = words.join(' ');
//console.log(result); // выведет 'Word1 Word2 Word3'

//let str =  'var-test-text';
//let arr = str.split('-'); //разделил строку на массивы по '-' удалив его
//for (let i = 0; i < arr.length; i++)
//{
//arr[i] = arr[i].slice(0, 1).toUpperCase() + arr[i].slice(1);// записываем каждый массив с верхним регистром в начале
//}
//let res = arr.join('');//объединяем массивы в строку
//console.log (res); //выведет VarTestText

//let str = '12345';
//let result = str.split('').reverse().join('');
//console.log(result); // выведет '54321'

//___________________________________________________
// 82 Основы работы с пользовательскими функциями

//Функция создается с помощью команды function. 
//Далее через пробел следует имя функции, круглые скобки, 
//а затем фигурные скобки, в которых пишется какой-то код:

//function func() {
// какой-то код
//}

//function func() {
//alert('!');
//}// создаем функцию
//func()//вызываем функцию, подтвердить действие '!'

//Функции могут быть вызваны до места своего определения:
//func(); // выведет '!'
//function func() {
//alert('!');
//}
//___________________________________________________
// 83 Параметры функций

//скобки не обязательно должны быть пустыми - в них мы можем передавать параметры.

//function func(num) 
//{
//alert(num * num);
//}
//func(2); // выведет 4
//func(3); // выведет 9
//}


//function func(num1, num2) {
//alert(num1 + num2);
//}
//func(1, 2); // выведет 3


//function func(num) {
//alert(num * num);
//Не обязательно параметром функции передавать именно число 
//- можно передать и переменную, содержащую нужное нам число:
//}
//let param = 2;
//func(param);//выведет подтвердить действие 4


//function func(name) {
//alert('ваше имя: ' + name);
//}
//func('Вася'); // выведет 'ваше имя: Вася'
//function func(name = 'Аноним') 
//{
//alert('ваше имя: ' + name);
//}
// Без параметра:
//func(); // выведет 'ваше имя: Аноним'
//func('Вася'); // выведет 'ваше имя: Вася'


//function func(name = 'Аноним', age = 'неизвестен') {
//alert('ваше имя: ' + name + ' возраст: ' + age);
//}
//func(); //выведет ваше имя: Аноним возраст: неизвестен
//func('Влад', 29); // выведет ваше имя: Влад возраст: 29

//___________________________________________________
// 84 Инструкция return
//оператор return завершает выполнение текущей функции и возвращает её значение.

//function func(num)
//{
//return num * num;
//}
//let result = func(3); // в переменной result теперь 9
//alert(result); // выведет 9
//alert (func(3)); // выведет 9

//function func(num) 
//{
//return num * num;
//}
//let result = func(2) + func(3);
//alert(result); // выведет 13

//function func(num) {
//return num * num;
///}
//let result = func(func(2));
//alert(result); // выведет 16

//function square(num) {
//return num * num;
//}
//function sum(num1, num2) {
//return num1 + num2;
//}
//let result = sum(square(2), square(3));
//alert(result); //выведет 13

//function func(num) {
//if (num >= 0) {
//return '+';
//} else {
//return '-';
//}
//alert('!'); // этот код никогда не выполнится
//}
//alert(func( 3)); // выведет '+'
//alert(func(-3)); // выведет '-'

//function func() {
	//let sum = 0;
	//for (let i = 1; i <= 5; i++) {
		//sum += i;
//	}
	//return sum;
//}
//let result = func();
//аlert(result); // выведет 15

//function func(arr) {
//let sum = 0;
//for (let i = 0; i < arr.length; i++) {
//sum += arr[i];
// Если сумма больше или равна 10:
//if (sum >= 10) {
//return i + 1; // выходим из цикла и из функции
//}
//}
//}
//let result = func([1, 2, 3, 4, 5]);
//alert(result);

//___________________________________________________
// 85 Примеры на создание функций

//function getSum(arr)
//{
	//let sum = 0;
	//for (let elem of arr)
	//{
	//sum += elem;
	//}
	//return sum;
//}
//let arr1 = [1, 2, 3, 4];
//let arr2 = [5, 6, 7, 8];
//alert(getSum(arr1));//выведет 10
//alert(getSum(arr2));//выведет 26

//___________________________________________________
// 86 Флаги в функциях
//function isPrime(num) {
//let flag = true;
//for (let i = 2; i < num; i++) {
//if (num % i == 0) {
//flag = false;
//break;
//}
//}	
//return flag;
//}
//console.log( isPrime(10) );
//console.log( isPrime(31) );

//function isPositive(arr) {
//for (let elem of arr) {
//if (elem < 0) {
//return false;
//}
//}
//return true;
//}
//console.log( isPositive([1, -2, 3, 4, -5]) ); // выведет false
//console.log( isPositive([1, 2, 3, 4, 5]) );   // выведет true

//___________________________________________________
// 87 Логические операторы без if в функциях
//конструкции if, возвращающие булевы значения, 
//можно переписывать в сокращенной форме.
//function func(a, b) {
//return a > b;
//}
//console.log (func(2, 5)); //выведет false

//_________________________________________________
// 88 Правильное использование функций
//let arr = [1524, 1321, 4563, 7144, 2879];
//let a =[];
//for (let elem of arr)
//{
//if (func(elem))
//{
//a.push (elem);
//}
//}
//console.log (a);
//function func(elements)
//{
//let b = String(elements);//так-как занчение элемента массива - значение(число) 
//нам нужно привести его в псевдомассив (строку) для дальнейшей обработки 
//let ca =   Number(b[0]) +  Number (b[1]);
//console.log (ca)
//let cb =   Number(b[2]) +  Number (b[3]);
//return ca == cb;// [1524, 4563, 7144]
//}

//_________________________________________________
// 89 Комбинация вспомогательных функций
//найдем квадрат суммы элементов этого массива, 
//используя комбинацию приведенных выше функций:
//function getsumm(arr)
//{
//let sum = 0;
//for (let elem of arr)
//{
//sum+=elem;
//}
//return sum;
//}
//function getSquare(num) 
//{
	//return num * num;
//}
//console.log( getSquare(getsumm([1, 2, 3, 4, 5])) );// выведет 225

//_________________________________________________
// 90 Вспомогательные функции внутри других функций

//function getDigits(num)
 //{
//let str = String(num);
//return str.split(''); // передает в функцию getDigits массив, созданный 
//из разбиения вводного параметра num ['1', '2', '3']c помощью функции split('') 
//}
//console.log(getDigits(123)); // выведет ['1', '2', '3']


//function getSum(arr)
//{
//let sum = 0;
//for (let elem of arr)
//{
//sum += Number(elem);
//}
//console.log (sum + sum) // выведет 12
//return sum;//передает сумму масива результат выполнения функции;//передает сумму масива результат выполнения функции
//}
//console.log (getSum(['1', '2', '3'])) //выведет 6

//function getDigits(num) //соберем оба предыдущих примера 
//{
//return String(num).split('');
//}
//function getSum(arr) 
//{
//let sum = 0;
//for (let elem of arr) 
//{
//sum += Number(elem);
//}	
//return sum;
//}
//let sum = getSum(getDigits(123));
//alert(sum); // выведет 6

//function inRange(num)
//{
//if (num >= 1 && num <= 9) {
//return true;
//}
//else 
//{
//return false;
//}
//}
//let n = 9
//console.log (inRange(n)) \\выведет true

//let arr = [12, 19, 28, 13, 14, 345];
//let result = [];
//function inRange(num) { //функция inRange проверяет на диапазон от 1-9
//let sum = getSum(getDigits(num));
//return sum >= 1 && sum <= 9;
//}
//function getSum(arr) { //суммирует части элементов в массива
//let sum = 0;
//for (let elem of arr) {
//sum += Number(elem);
//}
//return sum;
//}
//function getDigits(num) { //передает параметром элемент массива arr и разбивает его
//return String(num).split('');
//}
//for (let elem of arr) {//цикл записывает в массив если исполняется функция inRange 
//if (inRange(elem)) {
//result.push(elem);
//}
//}
//console.log(result);

//_________________________________________________
// 91 Дружественные числа


//_ _ _ _ функция проверяющая суммы на дружественность_ _ _

	//function isFreindly(num1, num2)
	//{
	//let sum1 = getSum(getOwnDivisors(num1)); //записываем в переменную сумму целых делителей первого числа
	//let sum2 = getSum(getOwnDivisors(num2)); //записываем в переменную сумму целых делителей второго числа
	//if (sum1 == num2 && sum2 == num1) // проверяем на дружественность
	//{
	//return true;
	//} 
	//else 
	//{
	//return false;
	//}
	//}
	
//_ _ _ _ функция создающая массив из переменной и 
//записывая его циклом (целые делители)_ _ _ 

	//function getOwnDivisors(num)
	//{
	//let arr = []; //объявляем массив куда запишем делители
	//for (let i=2; i<=num; i++) // перебирает все элементы числа
	//{
	//if (Number.isInteger(num/i) == true) // метод Number.isInteger -возвращает true если значение целое
	//{
	//arr.push (num/i)//создаем массив из целых делителей
	//}
	//}
	//console.log (arr)
	//return arr;//возвращаем в функцию созданный массив
	//}
//_ _ _ _ функция сложения массива_ _ _

	//function getSum(arr) 
	//{
	//let a = 0;
	//for (let i=0; i<=arr.length -1; i++) // условие с перебором (счетчик) с макс значением длинной массива
	//{
	//a += arr[i];// подсчиываем сумму значений массива и записываем в созданную переменную
	//}
	//return a;// возвращаем в функцию результат сложения
	//}
//_ _ _ _ конец_ _ _ 

	//console.log(isFreindly(220,284)) // выведет true 
	//(числа дружественны [110, 55, 44, 22, 20, 11, 10, 5, 4, 2, 1] и [142, 71, 4, 2, 1])
	
	//_________________________________________________
// 92 Пересечение массивов

//function getInt(arr1, arr2) {
	//let result = [];
	
	//for (let elem of arr1) {//цикл перебора элементов 1 массива
		//if (inArray(elem, arr2)) { //исполняет функцию которая возвращает первый индекс, по которому данный элемент может быть найден
			//result.push(elem); //записываем в отдельный иассив
		//}
	//}
	
	//return result;
//}

//function inArray(elem, arr){
	//return arr.indexOf(elem) !== -1;//условие проверки 
//}
//console.log( getInt([1, 2, 3], [2, 3, 4, 5]) );

//_________________________________________________
// 93 Разность массивов
//function inArray(elem, arr) {
	//if (arr.indexOf(elem) == -1) {
		//return false;
	//} else {
		//return true;
	//}
//}

//function getDiff(arr1, arr2) {
	//let result = [];
	
	//for (let elem of arr1) {
		//if (!inArray(elem, arr2)) {
		//result.push(elem);
		//}
	//}
	
	//for (let elem of arr2) {
		//if (!inArray(elem, arr1)) {
			//result.push(elem);
		//}
	//}
	
	//return result;
//}
//console.log( getDiff([1, 2, 3], [2, 3, 4, 5]) ); // выведет [1, 4, 5]

//_________________________________________________
// 94 Наибольший общий делитель
//_ _ _ создаем массив из целых делителей заданного числа
	//let nam1 = 1000;
	//let nam2 = 2500;
	//function numbersDivisor (nam)
	//{
	//let arr = [];
	//for (i=2; i <= nam; i++)
	//{
	//if (Number.isInteger(nam/i) == true)
	//{
	//arr.push (nam/i);
	//}
	//}
	//return arr;
	//}
	//let arr1 = (numbersDivisor (nam1));
	//console.log (arr1)
	//let arr2 = (numbersDivisor (nam2));
	//console.log (arr2)
//_ _ _ проверяем на совпадение элемента в другом массиве
	//function inArray(elem, arr) 
	//{
	//if (arr.indexOf(elem) == -1) 
	//{
	//return false;
	//}
	//else 
	//{
	//return true;
	//}
	//}
//_ _ _ записываем совпадение в единый массив
	//function getDiff(arr1, arr2) 
	//{
	//let result = [];
	//for (let elem of arr1)
	//{
	//if (inArray(elem, arr2)) 
	//{
	//result.push(elem);
	//}
	//}
	//for (let elem of arr2)
	//{
	//if (inArray(elem, arr1)) 
	//{
	//result.push(elem);
	//}
	//}
	//return result;
	//}
//_ _ _находим максимальное значение в массиве 
	//let mas = ( getDiff((numbersDivisor (nam1)), (numbersDivisor (nam2))) ); 
	//console.log (mas) 
	//let max = Math.max.apply(null, mas);
	//console.log(max);

//_________________________________________________
// 95 Наибольший общий делитель
	//function getRandomInt(min, max)// функция, возвращающая случайное целое значение в заданном диапазоне
	//{
	//return Math.floor(Math.random() * (max - min + 1)) + min;// метод Math.floor округляет значение в меншую сторону
	//}

	//function random(arr) // выбираем случайный элемент в массиве
	//{
	//let key = getRandomInt(0, arr.length - 1);
	//return arr[key];
	//}

	//let arr = [1, 2, 3, 4, 5];// выводим в консоль
	//console.log(random(arr));
	
	//_________________________________________________
// 100 Область видимости переменных в функциях

//let num = 1; //  переменные, определенные снаружи функции, 
//будут видны внутри этой функции. Такие переменные называются глобальными
//function func() 
//{
//alert(num); // переменная num видна внутри функции
//}
//func(); // выведет 1

//Если в одной из функций произойдут изменения с глобальной переменной,
//то эта переменная поменяется во всех функциях, использующих эту переменную:
//function func1()
 //{
	//alert(num);
	//num++; // меняем глобальную переменную
//}
//function func2() 
//{
	//alert(num);
//}
//let num = 1;
//func1(); // выведет 1
//func2(); // выведет 2

//Переменные, определенные внутри функции, называются локальными. В отличии от 
//глобальных переменных, локальные переменные видны только внутри функции, и не видны снаружи
//function func() 
//{
//let num = 5; // локальная переменная
//alert(num);
//}
//alert(num); // ничего не выведет, а выдаст ошибку в консоль

//let num = 1; // глобальная переменная
//function func() {
//let num = 2; // локальная переменная
//alert(num);
//}
//func(); // вызываем функцию, выведет 2
//alert(num); // выведет 1 - глобальная переменная не поменялась


//let num = 1;
//function func() {
//num = 2; // забыли написать let - меняем внешнюю переменную
//alert(num);
//}
//func(); // вызываем функцию, выведет 2
//alert(num); // выведет 2 - переменная поменялась

//let num = 1;
//function func() {
//num = 2;
//}
//alert(num); // выведет 1
//func(); // меняем переменную
//alert(num); // выведет 2

	//_________________________________________________
// 101 Область видимости и параметры функций
//внутри функции будет доступна как переменная localNum 
//(параметр функции), так и переменная num (как внешняя переменная)
//function func(localNum) 
//{
//alert(localNum);
//}
//let num = 1;
//func(num); // вызываем функцию с параметром, выведет 1

//Сама переменная localNum будет локальной переменной функции и не будет доступна извне
//function func(localNum) 
//{
//}
//let num = 1;
//func(num); // вызываем функцию с параметром
//alert(localNum); // выдаст ошибку

//Так как переменная localNum - локальная, то никакие изменения с ней ничего не поменяют снаружи:
//function func(localNum) 
//{
//localNum = 2; // ничего не меняет снаружи
//alert(localNum);
//}
//let num = 1;
//func(num);
//console.log (num)// выдаст 1
//console.log (localNum)// выдаст ошибку

	//_________________________________________________
// 102 Исходный код функции и ее результат

//function func() {
//return '!';
//}
//alert(func()); // выведет '!'
//console.log(func); // не пишем круглые скобки, увидим ее исходный код - function func() { return '!'; }.

	//_________________________________________________
// 103 Функция как переменная

//В JavaScript, в отличие от других языков, функции являются такими же значениями переменных,
// как числа, строки и массивы. Мы можем, к примеру, затереть переменную func чем-нибудь другим, 
//например, строкой.

//function func()
//{
//alert('!');
//}
//func(); // выведет '!'
//func = 'string'; // затрем переменную func
//alert(func); // выведет 'string'

//function func() 
//{
//alert('!');
//}
//let test = func; // теперь test такая же функция, как и func
// Проверим:
//test(); //выведет '!'
//func(); //выведет '!'

//в JavaScript существует альтернативный синтаксис для создания функции. Присваивается в какую-нибудь переменную. 
//Эта переменная и становится именем функции
//let func = function() {
//alert('!');
//};
//func(); // выведет '!'

	//_________________________________________________
// 104 Function expression и Function declaration
//По научному первый способ называется Function Declaration (объявление функции), 
//а второй - Function Expression (функциональное выражение).
// Обращаемся к функции до ее объявления:
//func(); //выведет '!'
//function func()
//{
//alert('!');
//}

//func(); //ошибка, такой функции еще нет!
//let func = function()
//{
//alert('!');
//};
/* Как вы должны уже знать, интерпретатор JavaScript обрабатывает код строка за строкой. 
Функции, однако, являются исключениями: интерпретатор вначале пробегается по всему документу 
с кодом и ищет все функции, объявленные как Function Declaration, и только потом начинает выполнять
 код документа построчно. Функции, созданные как Function Expression, создаются в тот момент, 
 когда до них доходит интерпретатор. Поэтому они и недоступны выше места своего объявления.*/
 
 	//_________________________________________________
// 105 Нюансы функциональных выражений

//function funk () 
//{
//return 2;
//};
//let str = 2 + funk()// пример сложения глобальной функции с переменной
//alert(str); // выведет 4


//let funk = function()
 //{
//return 2;
//};
//let str = 2 + funk(); пример сложения локальной функции с переменной
//alert(str); //  выведет 4

//let func = function()
//{
//return 2;
//};
//func();
//alert (function() {return 2;});

/*
	Данная функция будет Function Declaration,
	но с синтаксической ошибкой: она без имени
*/
//function() 
//{
//alert('!');
//}

//+function() { // такой код корректен, так как учавствует в выражении
//alert('!');
//};

//test(); // выведет ошибку в консоль, значит Function Expression
//let test = function() {
//alert('!');
//}

//func(); // выведет '!', значит Function Declaration
//function func() {
//alert('!');
//}

//let test = function func() { // это Function Expression
//alert('!');
//} + 1;

//alert(function func() { // это Function Expression
//alert('!');
//} + 1);

 	//_________________________________________________
// 106 Массив с анонимными функциями
//функции в JavaScript ведут себя, будто строки или числа.
//В частности, можно сделать массив, состоящий из функций.


//let arr = [
	//function() {alert('1')},
	//function() {alert('2')},
	//function() {alert('3')},
//];

//arr[0](); // выведет '1'
//for (let func of arr)
//{
	//func(); // вызываем наши функции в цикле
//}

 	//_________________________________________________
// 107 Объект с анонимными функциями

//let obj = {
	//func1: function() {alert(1)},
	//func2: function() {alert(2)},
	//func3: function() {alert(3)},
//};
//obj.func1(); // выведет 1

//let math = {
	//square: function(num) {return num * num},
	//cube: function(num) {return num * num * num},
//};
//alert( math.square(2) ); // выведет 4
//alert( math.cube(2) ); // выведет 8

 	//_________________________________________________
// 108 Передача функций параметрами

//function test(func1, func2) { //создаеи функцию
	//alert( func1() ); // выведет 1
	//alert( func2() ); // выведет 2
//}
//test(//вызываем функцию
	//function() {return 1;},
	//function() {return 2;}
//);//вызываем функцию с параметрами

 //function get1() {
	//return 1;
//}// создали функцию со значением 1
//function get2() {
	//return 2;
//}// создали функцию со значением 2

//function test(func1, func2) {// создали функцию test со сложением своих параметров
	//alert( func1() + func2() );
//}

//test(get1, get2); // вызов функции с заданными первичными параметрами - 1 и 2. Выведет 3


// Выведет 9:
//test(// вызов функции test которой передает в параметрах другую не объявленную функцию
	//function(num) {
		//return num * num;
	//}
//);
//function test(func) {//функция test с параметром - func
	//console.log(func(3));
//}

//function test(num, func) {
	//alert(func(num));
//}
// Выведет 4:
//test(2, function(num) {
	//return num * num;
//});

//function test(arr, funcs) 
//{
//for (let i = 0; i < arr.length; i++)
//{
//arr[i] = funcs(arr[i]);
//}
//return arr;
//}
//console.log (test ([1, 2, 3],function(r) {
//return r* r;
//}));



 	//_________________________________________________
// 109 Именованные функциональные выражения

//let test = function func() 
//{
//alert('!');
//};
//test(); // выведет '!'
//func(); // выдаст ошибку

//let test = function func() {
//alert('!'); // выводим '!'
//func(); // вызываем сами себя
//};
//test();// постоянно выводит ! 

//let test = function func() {
//alert('!');
//test(); // вызываем сами себя
//};
//test();

//function func()
//{
//alert('!');
//func(); // вызываем сами себя
//};
//func();

 	//_________________________________________________
// 110 Вложенные функции


//function square(num) {
//return num * num;
//}
//function func(num1, num2) {
//return square(num1) + square(num2);//пример последовательного выполнения
//}
//alert(func(2, 3)); // выведет 13

//function func(num1, num2) {
//function square(num) {//square вложен внутрь функции func
//return num * num;
//}
//return square(num1) + square(num2);
//}
//alert(func(2, 3)); // выведет 13
//alert(square(2)); // выдаст ошибку

//_________________________________________________
// 111 Область видимости вложенных функций

//Если функция содержит внутри другую функцию -
// переменные внешней функции видны во внутренней
//Также во внутренней функции будут видны переменные, 
//определенные снаружи внешней функции

//let num = 1; // глобальная переменная
//function test() {
//function func() {
//alert(num); // выведет 1
//}
//func(); // вызываем внутреннюю функцию
//};
//test(); // вызываем внешнюю функцию

//Параметры внешней функции также будут доступны во внутренней:
//function test(num) {
//function func() {
//alert(num); // выведет 1
//}
//func(); // вызываем внутреннюю функцию 
//};
//test(1); // передаем параметром число 

//function test(num) {
//function func(localNum) {
//alert(num); // выведет 1
//alert(localNum); // выведет 1
//}
//func(num);
//}
//test(1);
// во внутренней функции будет доступна переменная num как внешняя переменная 
//из родительской функции и переменная localNum, являющаяся локальной переменной 
//внутренней функции.Обе эти переменные будут иметь одинаковые значения

//function test(num) {
//function func(localNum) {
//num = 2; // меняем переменную num
//}
//func(num);   //передаем параметр 2 в функцию func  
//alert(num);  // выведет 2
//}
//test(1); // передаем параметром число 

/* переменная localNum будет локальной. Ее изменения не будут приводить ни к 
каким изменениям во внешней функции. Да и сама переменная localNum не будет 
видна снаружи внутренней функции: */

//function test(num) {
//function func(num) {
// тут нельзя получить доступ в внешней переменной num 
//}
//func(num);
//}
//test(1);

//_________________________________________________
// 112 Область видимости вложенных функций

//function func() {
//return function() {
//return '!';
//};
//}
//let result = func();// переменная result теперь представляет собой функцию func.
//alert(  result() ); // выведет '!'

/*так как вызов func() возвращает функцию, то мы можем сразу же и вызвать эту возвращаемую функцию,
 вот так: func()() - первые круглые скобки получают результат функции func (который сам является функцией), 
 а вторые круглые скобки применяются к результату func.*/
//function func() {
//return function() {
//return '!';
//};
//}
//alert( func()() ); // выведет '!'

//function func(num1) {
//return function(num2) {
//return num1 + num2;
//};
//}
//alert( func(1)(2) ); // выведет 3

//_________________________________________________
// 113 Лексическое окружение функций

//let num = 1; // функция в этот момент узнает, что num = 1
//func(); // выведет 1
//function func() {
//alert(num);
//}
//func(); // выведет 1
//num = 2; // функция в этот момент узнает, что num = 2
//func(); // выведет 2
//функция знает значения внешних переменных, даже не будучи вызванной

//let num1 = 1; // окружение {num1: 1}
//let num2 = 2; // окружение {num1: 1, num2: 2}
// Поменяем переменную num1:
//num1 = 123; // окружение {num1: 123, num2: 2}
//function func() {	
//}

//function test() {
//let num = 1;
//return function() {
//alert(num);
//}
//}
//let func = test();
//func(); // выведет 1
//alert(num); // переменная num тут недоступна

//_________________________________________________
// 114 Замыкания
//замыкание - это функция вместе со всеми внешними переменными,
// которые ей доступны. Или, другими словами, замыкание - это функция вместе 
//со своим лексическим окружением.
//function test() {
//let num = 1;
//return function() {
//alert(num);
//}
//}
//let func = test();
//func(); // выведет 1
//можно сказать, что функция func получает значение переменной num из замыкания. 
//Также можно сказать, что функция func хранит значение переменной num в замыкании.

//let num = 1;// делаем переменную глобальной так-как иначе в функции она будет мешать и выводя 
//себя при каждой итерации менять переменную num
//function test() // создаем Function declaration - test
//{
//return function() {//в функцию test вложена другая функция Function Expression (без имени)
//alert(num);//выводим на экран num
//num++;//увеличиваем на 1 в каждом вызове
//}
//}
//test()();//выведет 1
//test()();//выведет 2
//test()();//выведет 3
//test()();//выведет 4
//test()();//выведет 5

//function test() {
//let num = 1;
//return function() {
//alert(num);
//num++;
//}
//}
//let func = test();
//func(); //выведет 1
//func(); //выведет 2
//func(); //выведет 3
//func(); //выведет 4
//func(); //выведет 5

//_________________________________________________
// 115 Вызов функции на месте
//вызовем функцию сразу же, "на месте". Для этого после функции поставим круглые скобки:
//Наличие плюса в данном случае является обязательным условием, так как без него функция станет 
//Function Declaration, а их на месте (да еще без имени) вызывать нельзя. 
//+function() {
//alert('!'); // выведет '!'
//}();

//let sum = 1 + function() {
//return 2;
//}();
//alert(sum); // выведет 3

//(function ()// объяляем функциональное выражение в круглых скобках, может быть +, -
//{
//document.write ('Hello World'); // выводим на экран
//})(); //круглые скобки добавляются чтоб компилятор понял что это вызов с нулевым параметром

//let result = function() {
//return '!';
//}();
//alert(result); // выведет '!'() скобки ставить не нужно

// вызовем нашу функцию на месте, передав ей строку для вывода на экран:
//(function(str) {//объявление функции
//alert(str); // выведет '!!!'
//})('!!!');// параметр функции, делаем все без вызова функции(действует только с функциональными выражениями)

//(function() {// создаем функциональное выражение
	//return function(){ //передаем в выражение другое вложенное выражение
		//return function() {//передаем результат функциональное выражение
		//alert('!');//вывод !
		//};
	//};
//})()()();//// выведет '!' исполнение нескольких подрят функций

//;(function() {
	//alert(1); // выведет 1
//})();//для избежания проблем с ; в начале вызова функции на месте ставится ;


//_________________________________________________
// 116 Замыкания и вызов функции на месте

//let func = (function() {//создаем функциональное выражение 
	//let num = 1;//передаем переменную
	//return function() {//вложенное функй выражение, передаваемая в верхнюю функцию
		//alert(num);//выводим
		//num++;//добовляем в переменную +1
	//}
//})();//вызов функции
//func(); //выведет 1
//func(); //выведет 2
//func(); //выведет 3
//func(); //выведет 4
//func(); //выведет 5

//_________________________________________________
// 117 Понятие функции-коллбэка

//function square(num) {
//return num * num;
//}
//function each(arr, callback) {
//let result = [];
//for (let elem of arr) {
//result.push( callback(elem) ); // вызываем функцию-коллбэк
//}
//return result;
//}
//let result = each([1, 2, 3, 4, 5], square);
//console.log(result); // должно вывести [1, 4, 9, 16, 25]

//function square(num) {// объявление функции square
//return num * num; //передаем квадрат параметра
//};
//function each(arr) { // объявляем функцию each с параметром arr
//let result = []; // пустой массив который заполним
//for (let elem of arr) { //перебор массива
//result.push( square(elem) );//возвращаем результат функции
// выполнение функции square c параметром елементов массива
//}
//return result;//возвращаем массив result в функцию
//}
//console.log (each([1, 2, 3, 4, 5])); // выводит [1, 4, 9, 16, 25]

//function each(arr, callback) {
	//let result = [];
	//let i = 0;
	//for (let elem of arr) {
		//result.push( callback(elem, i++) ); // вторым параметром передаем счетчик
	//}
	//return result;
//}
//let result = each(['a', 'b', 'c', 'd', 'e'], function(elem, index) {
	//return elem + index;
//});
//console.log(result); // должно вывести ['a0', 'b1', 'c2', 'd3', 'e4']

//_________________________________________________
// 118 Стрелочные функции

//стрелочные функции, упрощающие синтаксис функций.
//первой написана обычная функция, а второй - соответствующая ей стрелочная (обе функции делают одно и тоже):
//let func1 = function(num1, num2) {
//let result = num1 * num2;
//return result;
//}

//           ||
//           \/

//let func2 = (num1, num2) => {
//let result = num1 * num2;
//return result;
//}

//Если в функции одна строка кода, то в стрелочных функциях можно не писать return и фигурные скобки:
//let func1 = function(num1, num2) {
//return num1 * num2
//}

//let func2 = (num1, num2) => num1 * num2;
//console.log (func2(5, 6));// выведет 30

//Если параметр стрелочной функции один - круглые скобки можно не писать:

//let func1 = function(num) {
//return num * num;
//}

//let func2 = num => num * num
//console.log (func2(5)); //выведет 25

//Если в функции вообще нет параметров - нужно писать пустые круглые скобки:

//let func1 = function() {
//alert('!!!');
//}

//let func2 = () => alert('!!!')
//console.log (func2()); //выведет '!!!'


//_________________________________________________
// 119 Работа с рекурсией
//В программировании есть такое понятие, как рекурсия - это когда функция вызывает сама себя
//let i = 1;
//function func(){//объявляем функцию
//console.log(i);// выводим глобальную переменную на экран
//i++;//добавляем +1
//if (i <= 10){// цикл до 10 
//func(); // здесь функция вызывает сама себя
//}
//}
//func(); //выведет значения от 1 до 10

//function func(arr) {
	//console.log(arr.shift()); // выведет 1 //используем метод shift
	//(выводит 1 элемент, а у самого массива 1 элемент заберает)
	//console.log(arr); // выведет [2, 3] - массив уменьшился
	
	//console.log(arr.shift()); // выведет 2
	//console.log(arr); // выведет [3] - массив уменьшился
	
	//console.log(arr.shift()); // выведет 3
	//console.log(arr); // выведет [] - массив пуст
//}
//func([1, 2, 3]);

//function func(arr) {//вызываем функцию
//console.log(arr.shift(), arr);
//используем метод shift
	//(выводит 1 элемент, а у самого массива 1 элемент заберает)
//if (arr.length != 0) {//условие пока массив не станет равным 0
//func(arr);
//}
//}
//func([1, 2, 3]);


//function getSum(arr) {//объявляет функцию
//let sum = arr.shift();//выводит первый элемент массива который его в последствии забирает
//if (arr.length !== 0) {//выполняет функцию до тех пор пока длинна массива не станет 0
//sum += getSum(arr); //складование элементов в переменную
//}
//return sum;//передача в функцию значения в переменной
//}
//console.log(getSum([1, 2, 3]));//выведет 6

//_________________________________________________
// 120 Рекурсия и многомерные структуры

//function func(arr) {//функция разбиения многомерного сложного массива
	//for (let elem of arr) {//перебор массива
		//if (typeof elem == 'object') {//оператор typeof возвращвет тип элемента
			//func(elem);//вызавает функцию разбиения (перебора) массива (саму себя) с параметром массива элемента
		//} else {
			//console.log(elem);//вывод элеиентов
		//}
	//}
//}
//func([1, [2, 7, 8], [3, 4, [5, [6, 7]]]]);//выведит от 1-до7

//_________________________________________________
// 121 Метод map для перебора массива

//специальный метод map, предназначенный для преобразования массивов. Этот метод работает следующим образом: 
//принимает параметром функцию-коллбэк и применяет ее для каждого элемента массива, а затем возвращает измененный массив.

//let arr = [1, 2, 3, 4, 5];//объявляем массив 
//let result = arr.map(function(elem) { //объявляем колбакк функцию
//console.log(elem); // последовательно выведет 1, 2, 3, 4, 5
//});

//let arr = [1, 2, 3, 4, 5];//объявляем массив 
//let result = arr.map(function(elem) {//возвращает в функцию квадрат параметра от функции
//return elem * elem;// возврат параметров
//});
//console.log(result); // выведет [1, 4, 9, 16, 25]

//Функция-коллбэк может также принимать второй параметр - в него JavaScript разместит ключ элемента массива.
//let arr = ['a', 'b', 'c', 'd', 'e'];

//let result = arr.map(function(elem, index) {
//return elem + index;
//});
//console.log(result); // выведет ['a0', 'b1', 'c2', 'd3', 'e4']

//let arr = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]; //объявляем многомерный массив
//let result = arr.map(function(elem)  перебираем массив ARR  и применяем элементы массива к функции 
//{
	//return elem.map(function(num) //перебираем вложенные массивы и выполняем функцию 
	//{
		//return num * num;//возвращаем в функцию квадрат параметра
	//});
//});
//document.write(result); //выведет 1,4,9,16,25,36,49,64,81


//let arr = ['123', '456', '789'];
//let str = [];
//for (let elem of arr) 
//{//перебор массива
//if (typeof elem == 'object') 
//{//оператор typeof возвращвет тип элемента
//console.log('массивов нет');
//} 
//else 
//{
//str.push( func(elem));//в противном случае в массив str записывается 
//результат выполнения функции func
//}
//}
//function func(elem) //объявляем функцию func c параметром elem - элементы массива arr
//{
//let arrh = elem.split();//применяем метод split - разбивает массив 
//по указанному разделителю () т.е. '123' - 123 и записываем в массив
//return arrh; //передаем результат в функцию
//}
//let m = [];//создаем массив мпустой пока
//let i = 0;//счетчик
//document.write(str)// выведет 123,456,789
//console.log (str)//123,456,789
//let result = str.map(function(elem) { //метод map для перебора массива str, с параметром функция-коллбэк,
// которая исполняется над каждым элементом массива
//for (let num of elem) //тело функции-коллбэк, циклом перебираем каждый подмассив 
//{
//m[i] = num.split('');//разбиваем строковые подмасивы на элементы
//i++;
//}
//return m;
//}); 
//let q = result;//передаем результат выполнения функции в переменную Q
//console.log(q.shift());// удаляем первый элемент выводит 0: (3) ['1', '2', '3']1: (3) ['4', '5', '6']2: (3) ['7', '8', '9'] 

//_________________________________________________
// 122 Метод forEach для перебора массива

//forEach работает также, как и метод map, только не возвращает измененный массив, 
//а просто вызывает функцию-коллбэк для каждого элемента массива. может также принимать 
//второй параметр - в него JavaScript разместит ключ элемента массива.

//let arr = ['a', 'b', 'c', 'd', 'e'];
//arr.forEach(function(elem, index) {
	//document.write(index + '.' + elem + '<br>');
//}); //выведет 0.a  1.b  2.c  3.d  4.e

//_________________________________________________
// 123 Метод filter для фильтрации массива

//Метод filter позволяет отфильтровать элементы массива. 
//Подобно уже изученным нами методам, этот метод в параметре получает функцию-коллбэк
// (с такими же параметрами, как и методы map и forEach), которая выполнится для каждого элемента массива.
//Своим результатом filter возвращает новый массив, в который войдут только те элементы, 
//для которых коллбэк вернет true

//let arr = [1, 2, 3, 4, 5];//объявляем массив
//let result = arr.filter(function(elem) { //применяем метод к массиву
	//if (elem % 2 == 0) {//если каждый элемент массива четный -остаток при делении на 2 равен 0 то
		//return true; //передать true
	//} else {//иначе
		//return false; //false
	//}
//});// в массив возвращаются все элементы с true
//console.log(result); // выведет [2, 4] // вывод результата в консоль

// Можно упростить 
//let arr = [1, 2, 3, 4, 5];
//let result = arr.filter(elem => elem % 2 == 0);
//console.log(result); // выведет [2, 4]

//ИЛИ
//let arr = [1, 2, 3, 4, 5];
//console.log( arr.filter(elem => elem % 2 == 0) );

//_________________________________________________
// 124 Метод every для проверки массива

//метод every проверяет элементы массива и возвращает true, 
//если для всех элементов массива коллбэк вернул true, в противном случае метод возвращает false.
//let arr = [2, 4, 6, 8];
//let result = arr.every(function(elem) {
//if (elem % 2 == 0) {
//return true;
//} 
//else 
//{
//return false;
//}
//});
//console.log(result);// вернет true

//_________________________________________________
// 125 Метод some для проверки массива 

//метод some проверяет элементы массива и возвращает true, 
//если хотя бы для одного элемента коллбэк вернул true, в противном случае метод возвращает false.

//let arr = [2, 4, 6, 8];
//let result = arr.some(function(elem) {
//return elem % 2 == 0;
//});
//console.log(result); // вернет true

//let arr = [21, 43, 5, 81];
//let result = arr.some(elem => elem % 2 == 0);
//console.log(result);// вернет false

//_________________________________________________
// 126 Оператор spread

//В ES6 появился специальный оператор ..., называющийся spread.
//Когда оператор spread стоит перед массивом, он разделяет этот 
//массив на отдельные значения, превращая массив в набор параметров,
//необходимых для вызова функции.

//function func(num1, num2, num3)
//{
//return num1 + num2 + num3;
//}
//console.log (func(...[1, 2, 3])); //выведет 6 (значения массива разбил и передал в параметры)


//function func(num1, num2, num3, num4, num5) {
//return num1 + num2 + num3 + num4 + num5;
//}
//console.log (func(1, ...[2, 3, 4], 5));//выведет 15

//let arr = [1, 2, 3, 4, 5]// объявляем массив
//let max = Math.max(...arr);//c помощью оператора spred передаем в параметры метода max 
//(нахождение максимального элемента в массиве) элементы
//console.log (max); //выведет 5

//_________________________________________________
// 127 Оператор spread и слияние массивов

//let arr1 = ['a', 'b', 'c'];
//let arr2 = [1, ...arr1, 2, 3];
//console.log(arr2); // выведет [1, 'a', 'b', 'c', 2, 3]

//_________________________________________________
// 128 Оператор spread для строк и чисел

//Оператор spread, примененный к строке, разбивает эту строку посимвольно: ...'abcde'; 
// разобьет строку в символы через запятую: 'a','b','c','d','e'

//let arr = [...'abcde']; // получим массив ['a', 'b', 'c', 'd', 'e']

//function func(s1, s2, s3, s4, s5) {
//return s1 + '-' + s2 + '-' + s3 + '-' + s4 + '-' + s5;
//}
//console.log( func(...'abcde') ); // передали параметром в функцию ...'abcde' -> выведет 'a-b-c-d-e'

//_________________________________________________
// 129 Оператор rest

//Этот оператор в зависимости от места в коде может называться либо оператором spread, либо оператором rest.

//func(1, 2, 3, 4, 5);
//function func(a, b, ...rest) {
//console.log(a); // выведет 1
//console.log(b); // выведет 2
//console.log(rest); // выведет [3, 4, 5]
	
//func(1, 2, 3, 4, 5)
//function func(...rest) {
//console.log(rest); //выведет [1, 2, 3, 4, 5]
//}

//_________________________________________________
// 130 Применение операторов rest и spread

//function func(...nums) {//объявляем функцию с оператором rest
//let sum = 0; //начальное значение суммы
//for (let num of nums) {//цикл перебирающий массив из параметров
//sum += num;//записываем сумму элементов в массив
//}
//return sum;//вывод суммы в функцию
//}
//let result = func(1, 2, 3);//объявляем функцию с параметрами
//console.log(result); // выведет 6

//let result = unite([1, 2, 3], [4, 5, 6], [7, 8, 9]); //дана переменная 
//в которой передано функциональное выражение с  массивом
//console.log(result); // выведет [ [1, 2, 3,] [4, 5, 6], [7, 8, 9] ]
//function unite(...arrs){ //функция передает себе в результат параметры
	//return arrs;//передача параметров
//}

//function merge(...arrs) //объявление функции
//{
//return [].concat(...arrs);//переделываем в один массив методом  concat -> array1.concat(array2);
//}
//let result = merge([1, 2, 3], [4, 5, 6], [7, 8, 9]);
//console.log(result); // выведет [1, 2, 3, 4, 5, 6, 7, 8, 9]

//_________________________________________________
// 131 Пересечение произвольного количества массивов

//function getInt(...arrs){//объявляем функцию getInt и передаем оператором rest массив arrs
//let result = [];// создаем пустой массив result
//let arr0 = arrs.shift(); //применяем к массиву arrs метод shift, который результатом возвращает первый элемент, 
//при этом сам массив уменьшается на первый элемент
//for (let elem of arr0) {//так как arr0 - тоже массив перебираем его циклом for вычленяя каждый элемент  
//if (inArrays(elem, arrs)) {//условие которое применяем к каждому элементу цикла for если оно true
//result.push(elem);// записываем в массив result если условие true
//}
//}
//return result;// передаем в результат функции массив result
//}

//function inArrays(elem, arrs){//объявляем функцию inArrays 
//for (let arr of arrs) {//перебираем оставшийся основной массив arrs
//if (inArray(elem, arr)) {//исполняем функцию inArray если она  trure - вернет trure,
//если она не false - вернет false
//return true;
//}
//}
	
//return false;
//}

//function inArray(elem, arr) {// объявляем функцию inArray 
//return arr.indexOf(elem) !== -1;//возвращаем результат исплнениения метода indexOf если число elem нашлось в массиве arr (не равно -1) 
//то условие верно -true 
//}

// Проверим работу:
//let result = getInt([1, 2, 3], [2, 3, 4], [4, 3, 2]);
//console.log(result); // выведет [2, 3]

//_________________________________________________
// 132 Деструктуризация массивов

//Деструктуризация массивов - данная операция предназначена для массовой записи элементов массива в переменные в одну строчку кода.
//let [переменная1, переменная2, переменная3] = массив;

//let arr = [2025, 12, 31];// объявляем массив 
//let [year, month, day] = arr;// передаем в массив переменных
//console.log(year);  // выведет 2025
//console.log(month); // выведет 12
//console.log(day);   // выведет 31


//function func()//объявляем функцию 
//{
//return [2025, 12, 31];// возвращаем в функцию
//}
//let [year, month, day] = func(); // передаем в массив переменных
//console.log(year);  // выведет 2025
//console.log(month); // выведет 12
//console.log(day);   // выведет 31

//Пропуск значений
//let arr = [2025, 12, 31];
//let [, month, day] = arr;
//console.log(month); // выведет 12
//console.log(day);   // выведет 31

//Меньше элементов
//let arr = [2025, 12];
//let [year, month, day] = arr;
//console.log(year);  // выведет 2025
//console.log(month); // выведет 12
//console.log(day);   // выведет undefined

//Пропуск значений
//let arr = [2025, 12, 31, 23, 59, 59];
//let [year, month, day] = arr;
//console.log(year);  // выведет 2025
//console.log(month); // выведет 12
//console.log(day);   // выведет 31

//Остаток
//let arr = [2025, 12, 31, 23, 59, 59];
//let [year, month, day, ...time] = arr; // ...time - Примененен оператор rest 
//console.log(year);  // выведет 2025
//console.log(month); // выведет 12
//console.log(day);   // выведет 31
//console.log(time);   // выведет [23, 59, 59]

//Значение по умолчанию
//let arr = [2025, 12];
//let [year, month, day = 1] = arr;
//console.log(year);  // выведет 2025
//console.log(month); // выведет 12
//console.log(day);   // выведет 1
//     ||
//     \/
//let arr = [2025, 12, 31];
//let [year, month, day = 1] = arr;
//console.log(year);  // выведет 2025
//console.log(month); // выведет 12
//console.log(day);   // выведет 31

//_________________________________________________
// 133 Деструктуризация объектов

//Кроме массивов можно также делать и деструктуризацию объектов. 

//let obj = {year:2025, month:12, day:31}; // создаем объект obj
//let {year, month, day} = obj; //создаем массив переменных
//console.log(year);  // выведет 2025
//console.log(month); // выведет 12
//console.log(day);   // выведет 31
//При деструктуризации объектов имена переменных должны совпадать в ключами объекта, 
//порядок переменных и элементов в объекте не имеет значения

//Другие имена переменных
//можно вместо массива переменных указать объект 
//let obj = {
//year:  2025,
//month: 12,
//day:   31,
//};
//let {year: y, month: m, day: d} = obj;
//console.log(y); // выведет 2025
//console.log(m); // выведет 12
//console.log(d); // выведет 31

//Значения по умолчанию
//let obj = {month:12,day:31};
//let {year = 2025, month, day} = obj;
//console.log(year);  // выведет 2025
//console.log(month); // выведет 12
//console.log(day);   // выведет 31

//Другие переменные и значения по умолчанию
//let obj = {
//month: 12,
//day:   31,
//};
//let {year:y = 2025, month, day} = obj;
//console.log(y);     // выведет 2025
//console.log(month); // выведет 12
//console.log(day);   // выведет 31

//Функции в качестве значения по умолчанию
//function func() 
//{
//return (new Date).getFullYear();//Метод getFullYear() возвращает год указанной даты по местному времени.
//}
//let obj = {
	//month: 12,
	//day:   31,
//};
//let {year = func(), month, day} = obj;
//console.log(year);  // выведет 2021
//console.log(month); // выведет 12
//console.log(day);   // выведет 31

//Объект из функции
//function func() {
//return obj = {year:2025, month:12, day:31};
//}
//let {year, month, day} = func();
//console.log(year);  // выведет 2021
//console.log(month); // выведет 12
//console.log(day);   // выведет 31


//бъявление переменных
//let obj = {
//year:  2025,
//month: 12,
//day:   31,
//};
//let year, month, day; // объявим переменные заранее

// Без команды let перед фигурными скобками эти фигурные скобки не будут 
//восприняты JavaScript как команда на деструктуризацию (а будут восприняты как блок кода):
//{year, month, day} = obj; // не будет работать

//({year, month, day} = obj);
//console.log(year);  // выведет 2025
//console.log(month); // выведет 12
//console.log(day);   // выведет 31

//_________________________________________________
// 134 Деструктуризация параметров функций

//func('str1', [2025, 12, 31], 'str2');

//function func(param1, [year, month, day], param2) {
//console.log(param1); // выведет 'str1'
	
//console.log(year);   // выведет 2025
//console.log(month);  // выведет 12
//console.log(day);    // выведет 31
	
//console.log(param2); // выведет 'str2'
//}

//Объекты в параметрах
//function func({year, month, day}) {
//console.log(year);  // выведет 2025
//console.log(month); // выведет 12
//console.log(day);   // выведет 31
//}
//func({year: 2025, month: 12, day: 31});

//_________________________________________________
// 135 Работа с объектом Date

//Работа с объектом Date
//let date = new Date();// создаем новый объект дата и присваиваем его к переменной date
//let Year = (date.getFullYear()); // год
//let Month =(date.getMonth());    // месяц
//let Dat =(date.getDate());     // день

//let Hours =(date.getHours());    // часы
//let Minutes =(date.getMinutes());  // минуты
//let Seconds =(date.getSeconds());  // секунды
//document.write ('Date-('+Year+ '.' + Month + '.' +  Dat + ') Time-'+ ' ' +Hours+ ':' +Minutes+ ':' +Seconds)// выводим дату и время

//_________________________________________________
// 136 Форматирование даты

//let date = new Date();// создаем новый объект дата и присваиваем его к переменной date
//let Year = addZero(date.getFullYear()); // год через функцию проверки простоты числа
//let Month =addZero(date.getMonth());    // месяц через функцию проверки простоты числа
//let Dat =addZero(date.getDate());     // день через функцию проверки простоты числа

//let Hours =addZero(date.getHours());    // часы через функцию проверки простоты числа
//let Minutes =addZero(date.getMinutes());  // минуты через функцию проверки простоты числа
//let Seconds =addZero(date.getSeconds());  // секунды через функцию проверки простоты числа

//function addZero(num) {// функция добавляющая 0 в начало значения если это число от 0 до 9
//if (num >= 0 && num <= 9) {
//return '0' + num;
//} else
//{
//return num;
//}
//}
//document.write ('Date-('+Year+ '.' + Month + '.' +  Dat + ') Time-'+ ' ' +Hours+ ':' +Minutes+ ':' +Seconds)
//let massdat  = Year + '-' + Month + '-' +  Dat + '-' + Hours+ '-' +Minutes+ '-' +Seconds;
//console.log (massdat); // выведет 2021-10-27-15-23-41
//let arr = massdat.split('-');
//console.log(arr);//выведет ['2021', '10', '27', '15', '23', '41']
//let result = massdat.split('-').reverse().join('/');
//console.log(result); //выведет 51/26/15/27/10/2021

//_________________________________________________
// 137 Получения дня недели
//С помощью объекта Date можно также получить номер текущего дня недели. Делается это с помощью метода getDay. 
//Этот метод возвращает числа от 0 до 6-ти, причем неделя начинается с воскресенья и этот день имеет номер 0. 
//Понедельник - это день номер 1, вторник - номер 2 и так далее.

//let date = new Date();
//console.log(date.getDay());

//_________________________________________________
// 138 Вывод частей даты словом
//let date = new Date();// создаем новый объект дата и присваиваем его к переменной date
//let day  = date.getDay();// возвращает значение дня недели от 0 до 6
//let days = ['вс', 'пн', 'вт', 'ср', 'чт', 'пт', 'сб'];
//cоnsole.log(days[day]);// выводим нужный элемент из массива 

//_________________________________________________
// 139 Установка времени в объекте
//передать ему параметры в формате new Date(год, месяц, день, часы, минуты, секунды, миллисекунды) 
//и в этом случае в переменную date запишется не текущий момент времени, а тот, который мы указали в параметрах.
//let date = new Date(1992, 06, 20); // установим 5 ноября 2025 года
//let day  = date.getDay();
//let days = ['вс', 'пн', 'вт', 'ср', 'чт', 'пт', 'сб']; 
//console.log(days[day]);//выведет 'пн'

//_________________________________________________
// 140 Работа с getTime
//Существует специальный метод getTime, с помощью которого можно получить время в формате timestamp.
//Определяем сколько нам лет
//let now  = new Date();//текущее время 
//let date = new Date(1992, 06, 20, 00, 00, 00); //время 20.06.1992
//let diff = now.getTime() - date.getTime();//переводим значения в timstemp, 
//определяем разницу в милисекундах
//let Year =  Math.round((diff / (1000 * 60 * 60*24 ))/365);//милисекунды в года и округляем по правилам методом Math.round
//console.log (Year);//выведет 29

//_________________________________________________
// 141 Разница между объектами с датой

//В предыдущих уроках для нахождения разницы между датами мы использовали формат timestamp.В предыдущих уроках 
//для нахождения разницы между датами мы использовали формат timestamp.

//let now  = new Date();//текущее время 
//let date = new Date(1992, 06, 20, 00, 00, 00); //время 20.06.1992
//let diff = now - date;//переводим значения,определяем разницу в милисекундах
//let Year =  Math.round((diff / (1000 * 60 * 60*24 ))/365);//милисекунды в года и округляем по правилам методом Math.round
//console.log (Year);//выведет 29

//_________________________________________________
// 142 Автоматическая корректировка дат
//JavaScript имеет очень интересную и полезную особенность: если при создании объекта Date был указан некорректный момент времени - он
// автоматически будет пересчитан в корректный.
//let date = new Date(2018, 0, 35);
//console.log(date); // получится 4 февраля -Sun Feb 04 2018 00:00:00 GMT+0300 (Москва, стандартное время)
//document.write (date)

//Отрицательные значения
//let date = new Date(2018, -1, 1); // указываем -1 месяц
//console.log(date); // получится 1 декабря 2017 года

//Нулевой день
//let date = new Date(2018, 1, 0); // указываем нулевой день
//console.log(date); // получится 31 января

//Часы, минуты, секунды
//let date = new Date(2018, 0, 1, 25, 0, 0); // указываем 25-тый час
//console.log(date); // получится 2 января, 1 час
//_________________________________________________
// 143 Нахождение последнего дня месяца

//function getLastDay(month, year)//объявлявем функцию определения дней в месяце
//{
//let lastDays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; //создакм массив из дней месяцев
	//if (month != 1) //выводим значения элементов массива кроме 2 (значение1) 
	//{
		//return lastDays[month]; //передача в результвт функции если month не равен 1
	//}
	//else //в противном случае 
	//{
		//let date = new Date(year, 2, 0);//передать в переменную дату год с коррекцией даты
		//if (date.getDate() == 29) если в результат исполнения метода вывода даты date.getDate будет равен 29
		//{
		//return('29');//передать в функцию 29
		//} 
		//else //иначе 
		//{
		//return('28');//передать в функцию 28
		//}	
	//}
//}
//console.log (getLastDay(1, 2021)); //выводим в консоль результат исполнения фунции с заданными параметрами

//_________________________________________________
// 144 Проверка корректности даты 

//JavaScript автоматически корректирует даты, как организовать проверку на коррктность написания
//let year  = 2025; //создаем переменные из значений даты передаваемые в параметры объекта дата
//let month = 0;//создаем переменные из значений даты передаваемые в параметры объекта дата
//let day   = 32;//создаем переменные из значений даты передаваемые в параметры объекта дата

//let date = new Date(year, month, day);//создаем объект с параметрами переданными от переменных

//if (date.getFullYear() == year && date.getMonth() == month && date.getDate() == day)//условие если переменная год равна 
//году полученному методом итд. то,,,
//{
//console.log('корректна');
//} 
//else //в противном случае
//{
//console.log('некорректна');
//}

//_________________________________________________
// 145 Получение моментов времени

//День текущего года
//let date = new Date(); // получаем текущий момент
//console.log (new Date(date.getFullYear(),2,8))// выводим в консоль дату объект с параметрами, где год -
// результат выполнения метода date.getFullYear()

//День следующего или предыдущего года
//let date = new Date(); // получаем текущий момент
//console.log (new Date(date.getFullYear()+1,2,8))// выводим в консоль дату объект с параметрами, где год -
// результат выполнения метода date.getFullYear()+1 - на год болше --> Tue Mar 08 2022 00:00:00 GMT+0300 (Москва, стандартное время)

//Момент времени дня
//let now  = new Date();//создаем объект дату
//let date = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 12);//где now.getFullYear(), now.getMonth(), now.getDate() - 
//методы нахождения текущей даты, а 12 - задаем часы console.log  (date)//выведет Sat Nov 27 2021 12:00:00 GMT+0300 (Москва, стандартное время)

//Циклическая проверка
//Давайте найдем все первые числа месяцев текущего года, которые являются воскресеньем:
//let now  = new Date();//объявляем переменную now с текущей датой
//let year = now.getFullYear();// записываем в переменную year текущий год при помощи метода now.getFullYear()
//for (let month = 0; month <= 11; month++) {//цикл перебирающий месяцы
//let date = new Date(year, month, 1); //записываем в переменную date дату где параметр год - текущий год, месяц - значение из цикла, а день = 1
//if (date.getDay() == 0) {//если текущая 'вс'
//console.log(year + '-' + month + '-1');//выведет 2021-7-1
//}
//}

//_________________________________________________
// 147 Строковое сравнение дат
//Дело в том, что наши даты представляют собой строки и JavaScript сравнивает их как строки. То есть он сначала сравнивает первые символы двух дат: 
//если они одинаковы, то JavaScript сравнивает вторые символы, и так далее, пока не найдет отличия.
//let date1 = '2020-12-01';
//let date2 = '2019-12-01';
//console.log(date1 > date2); // выведет true

//_________________________________________________
// 148 Сравнение объектов с датами 

//let date1 = new Date(2020, 1, 1); //создаем объект дату с определенными параметрами и присваиваем ее к переменной 
//let date2 = new Date(2019, 1, 1);//создаем объект дату с определенными параметрами и присваиваем ее к переменной
//console.log(date1 > date2); // выведет true

//_________________________________________________
// 149 Количество времени до ближайшей даты

//let now  = new Date(); // создаем объект дату и присваиваем переменной now
//let date = new Date(now.getFullYear(), 2, 8); // текущий год,3 месяц, 8 день (8марта текущего года)
//let diff = date - now; // разница
//if (diff > 0) {// если больше 0 то 
	//alert ('еще будет')
//} else if (diff == 0) {
	//alert ('сегодня')
//} else {
	//alert ('в следующем году')
//}

//_________________________________________________
// 150 Основы работы с DOM

</script>

	</body>
</html>

